# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rexml` gem.
# Please instead update this file by running `bin/tapioca gem rexml`.


# source://rexml//lib/rexml/attlistdecl.rb#18
class REXML::AttlistDecl < ::REXML::Child
  include ::Enumerable

  # source://rexml//lib/rexml/attlistdecl.rb#29
  def initialize(source); end

  # source://rexml//lib/rexml/attlistdecl.rb#38
  def [](key); end

  # source://rexml//lib/rexml/attlistdecl.rb#50
  def each(&block); end

  # source://rexml//lib/rexml/attlistdecl.rb#22
  def element_name; end

  # source://rexml//lib/rexml/attlistdecl.rb#44
  def include?(key); end

  # source://rexml//lib/rexml/attlistdecl.rb#59
  def node_type; end

  # source://rexml//lib/rexml/attlistdecl.rb#55
  def write(out, indent = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/attribute.rb#10
class REXML::Attribute
  include ::REXML::Node
  include ::REXML::XMLTokens
  include ::REXML::Namespace

  # source://rexml//lib/rexml/attribute.rb#42
  def initialize(first, second = T.unsafe(nil), parent = T.unsafe(nil)); end

  # source://rexml//lib/rexml/attribute.rb#106
  def ==(other); end

  # source://rexml//lib/rexml/attribute.rb#163
  def clone; end

  # source://rexml//lib/rexml/attribute.rb#132
  def doctype; end

  # source://rexml//lib/rexml/attribute.rb#15
  def element; end

  # source://rexml//lib/rexml/attribute.rb#171
  def element=(element); end

  # source://rexml//lib/rexml/attribute.rb#111
  def hash; end

  # source://rexml//lib/rexml/attribute.rb#197
  def inspect; end

  # source://rexml//lib/rexml/attribute.rb#95
  def namespace(arg = T.unsafe(nil)); end

  # source://rexml//lib/rexml/attribute.rb#193
  def node_type; end

  # source://rexml//lib/rexml/attribute.rb#157
  def normalized=(new_normalized); end

  # source://rexml//lib/rexml/attribute.rb#70
  def prefix; end

  # source://rexml//lib/rexml/attribute.rb#184
  def remove; end

  # source://rexml//lib/rexml/attribute.rb#140
  def to_s; end

  # source://rexml//lib/rexml/attribute.rb#121
  def to_string; end

  # source://rexml//lib/rexml/attribute.rb#149
  def value; end

  # source://rexml//lib/rexml/attribute.rb#189
  def write(output, indent = T.unsafe(nil)); end

  # source://rexml//lib/rexml/attribute.rb#203
  def xpath; end
end

# source://rexml//lib/rexml/element.rb#2128
class REXML::Attributes < ::Hash
  # source://rexml//lib/rexml/element.rb#2147
  def initialize(element); end

  # source://rexml//lib/rexml/element.rb#2524
  def <<(attribute); end

  # source://rexml//lib/rexml/element.rb#2172
  def [](name); end

  # source://rexml//lib/rexml/element.rb#2356
  def []=(name, value); end

  # source://rexml//lib/rexml/element.rb#2524
  def add(attribute); end

  # source://rexml//lib/rexml/element.rb#2477
  def delete(attribute); end

  # source://rexml//lib/rexml/element.rb#2546
  def delete_all(name); end

  # source://rexml//lib/rexml/element.rb#2274
  def each; end

  # source://rexml//lib/rexml/element.rb#2241
  def each_attribute; end

  # source://rexml//lib/rexml/element.rb#2300
  def get_attribute(name); end

  # source://rexml//lib/rexml/element.rb#2572
  def get_attribute_ns(namespace, name); end

  # source://rexml//lib/rexml/element.rb#2212
  def length; end

  # source://rexml//lib/rexml/element.rb#2433
  def namespaces; end

  # source://rexml//lib/rexml/element.rb#2408
  def prefixes; end

  # source://rexml//lib/rexml/element.rb#2212
  def size; end

  # source://rexml//lib/rexml/element.rb#2194
  def to_a; end
end

# source://rexml//lib/rexml/cdata.rb#5
class REXML::CData < ::REXML::Text
  # source://rexml//lib/rexml/cdata.rb#16
  def initialize(first, whitespace = T.unsafe(nil), parent = T.unsafe(nil)); end

  # source://rexml//lib/rexml/cdata.rb#26
  def clone; end

  # source://rexml//lib/rexml/cdata.rb#35
  def to_s; end

  # source://rexml//lib/rexml/cdata.rb#39
  def value; end

  # source://rexml//lib/rexml/cdata.rb#60
  def write(output = T.unsafe(nil), indent = T.unsafe(nil), transitive = T.unsafe(nil), ie_hack = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/child.rb#9
class REXML::Child
  include ::REXML::Node

  # source://rexml//lib/rexml/child.rb#18
  def initialize(parent = T.unsafe(nil)); end

  # source://rexml//lib/rexml/child.rb#91
  def bytes; end

  # source://rexml//lib/rexml/child.rb#85
  def document; end

  # source://rexml//lib/rexml/node.rb#11
  def next_sibling; end

  # source://rexml//lib/rexml/child.rb#68
  def next_sibling=(other); end

  # source://rexml//lib/rexml/child.rb#11
  def parent; end

  # source://rexml//lib/rexml/child.rb#52
  def parent=(other); end

  # source://rexml//lib/rexml/node.rb#17
  def previous_sibling; end

  # source://rexml//lib/rexml/child.rb#79
  def previous_sibling=(other); end

  # source://rexml//lib/rexml/child.rb#37
  def remove; end

  # source://rexml//lib/rexml/child.rb#29
  def replace_with(child); end
end

# source://rexml//lib/rexml/comment.rb#7
class REXML::Comment < ::REXML::Child
  include ::Comparable

  # source://rexml//lib/rexml/comment.rb#24
  def initialize(first, second = T.unsafe(nil)); end

  # source://rexml//lib/rexml/comment.rb#63
  def <=>(other); end

  # source://rexml//lib/rexml/comment.rb#70
  def ==(other); end

  # source://rexml//lib/rexml/comment.rb#33
  def clone; end

  # source://rexml//lib/rexml/comment.rb#75
  def node_type; end

  # source://rexml//lib/rexml/comment.rb#14
  def string; end

  # source://rexml//lib/rexml/comment.rb#14
  def string=(_arg0); end

  # source://rexml//lib/rexml/comment.rb#14
  def to_s; end

  # source://rexml//lib/rexml/comment.rb#50
  def write(output, indent = T.unsafe(nil), transitive = T.unsafe(nil), ie_hack = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/xpath_parser.rb#11
module REXML::DClonable; end

# source://rexml//lib/rexml/doctype.rb#242
class REXML::Declaration < ::REXML::Child
  # source://rexml//lib/rexml/doctype.rb#243
  def initialize(src); end

  # source://rexml//lib/rexml/doctype.rb#248
  def to_s; end

  # source://rexml//lib/rexml/doctype.rb#255
  def write(output, indent); end
end

# source://rexml//lib/rexml/doctype.rb#51
class REXML::DocType < ::REXML::Parent
  include ::REXML::XMLTokens

  # source://rexml//lib/rexml/doctype.rb#80
  def initialize(first, parent = T.unsafe(nil)); end

  # source://rexml//lib/rexml/doctype.rb#185
  def add(child); end

  # source://rexml//lib/rexml/doctype.rb#125
  def attribute_of(element, attribute); end

  # source://rexml//lib/rexml/doctype.rb#115
  def attributes_of(element); end

  # source://rexml//lib/rexml/doctype.rb#135
  def clone; end

  # source://rexml//lib/rexml/doctype.rb#173
  def context; end

  # source://rexml//lib/rexml/doctype.rb#66
  def entities; end

  # source://rexml//lib/rexml/doctype.rb#181
  def entity(name); end

  # source://rexml//lib/rexml/doctype.rb#66
  def external_id; end

  # source://rexml//lib/rexml/doctype.rb#66
  def name; end

  # source://rexml//lib/rexml/doctype.rb#66
  def namespaces; end

  # source://rexml//lib/rexml/doctype.rb#111
  def node_type; end

  # source://rexml//lib/rexml/doctype.rb#229
  def notation(name); end

  # source://rexml//lib/rexml/doctype.rb#221
  def notations; end

  # source://rexml//lib/rexml/doctype.rb#195
  def public; end

  # source://rexml//lib/rexml/doctype.rb#207
  def system; end

  # source://rexml//lib/rexml/doctype.rb#149
  def write(output, indent = T.unsafe(nil), transitive = T.unsafe(nil), ie_hack = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/document.rb#35
class REXML::Document < ::REXML::Element
  # source://rexml//lib/rexml/document.rb#92
  def initialize(source = T.unsafe(nil), context = T.unsafe(nil)); end

  # source://rexml//lib/rexml/document.rb#170
  def <<(child); end

  # source://rexml//lib/rexml/document.rb#170
  def add(child); end

  # source://rexml//lib/rexml/document.rb#209
  def add_element(arg = T.unsafe(nil), arg2 = T.unsafe(nil)); end

  # source://rexml//lib/rexml/document.rb#120
  def clone; end

  # source://rexml//lib/rexml/document.rb#241
  def doctype; end

  # source://rexml//lib/rexml/document.rb#442
  def document; end

  # source://rexml//lib/rexml/document.rb#290
  def encoding; end

  # source://rexml//lib/rexml/document.rb#433
  def entity_expansion_count; end

  # source://rexml//lib/rexml/document.rb#129
  def expanded_name; end

  # source://rexml//lib/rexml/document.rb#129
  def name; end

  # source://rexml//lib/rexml/document.rb#110
  def node_type; end

  # source://rexml//lib/rexml/document.rb#435
  def record_entity_expansion; end

  # source://rexml//lib/rexml/document.rb#225
  def root; end

  # source://rexml//lib/rexml/document.rb#305
  def stand_alone?; end

  # source://rexml//lib/rexml/document.rb#275
  def version; end

  # source://rexml//lib/rexml/document.rb#365
  def write(*arguments); end

  # source://rexml//lib/rexml/document.rb#258
  def xml_decl; end

  private

  # source://rexml//lib/rexml/document.rb#447
  def build(source); end

  class << self
    # source://rexml//lib/rexml/document.rb#415
    def entity_expansion_limit; end

    # source://rexml//lib/rexml/document.rb#408
    def entity_expansion_limit=(val); end

    # source://rexml//lib/rexml/document.rb#429
    def entity_expansion_text_limit; end

    # source://rexml//lib/rexml/document.rb#422
    def entity_expansion_text_limit=(val); end

    # source://rexml//lib/rexml/document.rb#401
    def parse_stream(source, listener); end
  end
end

# source://rexml//lib/rexml/element.rb#271
class REXML::Element < ::REXML::Parent
  include ::REXML::XMLTokens
  include ::REXML::Namespace

  # source://rexml//lib/rexml/element.rb#319
  def initialize(arg = T.unsafe(nil), parent = T.unsafe(nil), context = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1237
  def [](name_or_index); end

  # source://rexml//lib/rexml/element.rb#1336
  def add_attribute(key, value = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1367
  def add_attributes(hash); end

  # source://rexml//lib/rexml/element.rb#723
  def add_element(element, attrs = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#646
  def add_namespace(prefix, uri = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1138
  def add_text(text); end

  # source://rexml//lib/rexml/element.rb#1278
  def attribute(name, namespace = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#278
  def attributes; end

  # source://rexml//lib/rexml/element.rb#1411
  def cdatas; end

  # source://rexml//lib/rexml/element.rb#383
  def clone; end

  # source://rexml//lib/rexml/element.rb#1432
  def comments; end

  # source://rexml//lib/rexml/element.rb#281
  def context; end

  # source://rexml//lib/rexml/element.rb#281
  def context=(_arg0); end

  # source://rexml//lib/rexml/element.rb#1386
  def delete_attribute(key); end

  # source://rexml//lib/rexml/element.rb#769
  def delete_element(element); end

  # source://rexml//lib/rexml/element.rb#678
  def delete_namespace(namespace = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#470
  def document; end

  # source://rexml//lib/rexml/element.rb#921
  def each_element(xpath = T.unsafe(nil), &block); end

  # source://rexml//lib/rexml/element.rb#838
  def each_element_with_attribute(key, value = T.unsafe(nil), max = T.unsafe(nil), name = T.unsafe(nil), &block); end

  # source://rexml//lib/rexml/element.rb#895
  def each_element_with_text(text = T.unsafe(nil), max = T.unsafe(nil), name = T.unsafe(nil), &block); end

  # source://rexml//lib/rexml/element.rb#278
  def elements; end

  # source://rexml//lib/rexml/element.rb#940
  def get_elements(xpath); end

  # source://rexml//lib/rexml/element.rb#1044
  def get_text(path = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1306
  def has_attributes?; end

  # source://rexml//lib/rexml/element.rb#785
  def has_elements?; end

  # source://rexml//lib/rexml/element.rb#993
  def has_text?; end

  # source://rexml//lib/rexml/element.rb#508
  def ignore_whitespace_nodes; end

  # source://rexml//lib/rexml/element.rb#358
  def inspect; end

  # source://rexml//lib/rexml/element.rb#1453
  def instructions; end

  # source://rexml//lib/rexml/element.rb#613
  def namespace(prefix = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#586
  def namespaces; end

  # source://rexml//lib/rexml/element.rb#954
  def next_element; end

  # source://rexml//lib/rexml/element.rb#1159
  def node_type; end

  # source://rexml//lib/rexml/element.rb#560
  def prefixes; end

  # source://rexml//lib/rexml/element.rb#970
  def previous_element; end

  # source://rexml//lib/rexml/element.rb#528
  def raw; end

  # source://rexml//lib/rexml/element.rb#443
  def root; end

  # source://rexml//lib/rexml/element.rb#422
  def root_node; end

  # source://rexml//lib/rexml/element.rb#1021
  def text(path = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1080
  def text=(text); end

  # source://rexml//lib/rexml/element.rb#1469
  def texts; end

  # source://rexml//lib/rexml/element.rb#485
  def whitespace; end

  # source://rexml//lib/rexml/element.rb#1495
  def write(output = T.unsafe(nil), indent = T.unsafe(nil), transitive = T.unsafe(nil), ie_hack = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1183
  def xpath; end

  private

  # source://rexml//lib/rexml/element.rb#1512
  def __to_xpath_helper(node); end

  # source://rexml//lib/rexml/element.rb#1527
  def each_with_something(test, max = T.unsafe(nil), name = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/doctype.rb#261
class REXML::ElementDecl < ::REXML::Declaration
  # source://rexml//lib/rexml/doctype.rb#262
  def initialize(src); end
end

# source://rexml//lib/rexml/element.rb#1582
class REXML::Elements
  include ::Enumerable

  # source://rexml//lib/rexml/element.rb#1595
  def initialize(parent); end

  # source://rexml//lib/rexml/element.rb#1912
  def <<(element = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1667
  def [](index, name = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1722
  def []=(index, element); end

  # source://rexml//lib/rexml/element.rb#1912
  def add(element = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1975
  def collect(xpath = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1812
  def delete(element); end

  # source://rexml//lib/rexml/element.rb#1838
  def delete_all(xpath); end

  # source://rexml//lib/rexml/element.rb#1954
  def each(xpath = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1742
  def empty?; end

  # source://rexml//lib/rexml/element.rb#1760
  def index(element); end

  # source://rexml//lib/rexml/element.rb#2060
  def inject(xpath = T.unsafe(nil), initial = T.unsafe(nil)); end

  # source://rexml//lib/rexml/element.rb#1610
  def parent; end

  # source://rexml//lib/rexml/element.rb#2084
  def size; end

  # source://rexml//lib/rexml/element.rb#2108
  def to_a(xpath = T.unsafe(nil)); end

  private

  # source://rexml//lib/rexml/element.rb#2116
  def literalize(name); end
end

# source://rexml//lib/rexml/encoding.rb#4
module REXML::Encoding
  # source://rexml//lib/rexml/encoding.rb#29
  def decode(string); end

  # source://rexml//lib/rexml/encoding.rb#25
  def encode(string); end

  # source://rexml//lib/rexml/encoding.rb#6
  def encoding; end

  # source://rexml//lib/rexml/encoding.rb#7
  def encoding=(encoding); end

  private

  # source://rexml//lib/rexml/encoding.rb#34
  def find_encoding(name); end
end

# source://rexml//lib/rexml/entity.rb#7
class REXML::Entity < ::REXML::Child
  include ::REXML::XMLTokens

  # source://rexml//lib/rexml/entity.rb#33
  def initialize(stream, value = T.unsafe(nil), parent = T.unsafe(nil), reference = T.unsafe(nil)); end

  # source://rexml//lib/rexml/entity.rb#22
  def external; end

  # source://rexml//lib/rexml/entity.rb#22
  def name; end

  # source://rexml//lib/rexml/entity.rb#22
  def ndata; end

  # source://rexml//lib/rexml/entity.rb#85
  def normalized; end

  # source://rexml//lib/rexml/entity.rb#138
  def parent=(other); end

  # source://rexml//lib/rexml/entity.rb#22
  def pubid; end

  # source://rexml//lib/rexml/entity.rb#22
  def ref; end

  # source://rexml//lib/rexml/entity.rb#119
  def to_s; end

  # source://rexml//lib/rexml/entity.rb#73
  def unnormalized; end

  # source://rexml//lib/rexml/entity.rb#134
  def value; end

  # source://rexml//lib/rexml/entity.rb#97
  def write(out, indent = T.unsafe(nil)); end

  private

  # source://rexml//lib/rexml/entity.rb#144
  def resolve_value; end

  class << self
    # source://rexml//lib/rexml/entity.rb#66
    def matches?(string); end
  end
end

# source://rexml//lib/rexml/doctype.rb#267
class REXML::ExternalEntity < ::REXML::Child
  # source://rexml//lib/rexml/doctype.rb#268
  def initialize(src); end

  # source://rexml//lib/rexml/doctype.rb#272
  def to_s; end

  # source://rexml//lib/rexml/doctype.rb#275
  def write(output, indent); end
end

# source://rexml//lib/rexml/formatters/default.rb#5
class REXML::Formatters::Default
  # source://rexml//lib/rexml/formatters/default.rb#12
  def initialize(ie_hack = T.unsafe(nil)); end

  # source://rexml//lib/rexml/formatters/default.rb#23
  def write(node, output); end

  protected

  # source://rexml//lib/rexml/formatters/default.rb#98
  def write_cdata(node, output); end

  # source://rexml//lib/rexml/formatters/default.rb#92
  def write_comment(node, output); end

  # source://rexml//lib/rexml/formatters/default.rb#61
  def write_document(node, output); end

  # source://rexml//lib/rexml/formatters/default.rb#65
  def write_element(node, output); end

  # source://rexml//lib/rexml/formatters/default.rb#104
  def write_instruction(node, output); end

  # source://rexml//lib/rexml/formatters/default.rb#88
  def write_text(node, output); end
end

# source://rexml//lib/rexml/formatters/pretty.rb#10
class REXML::Formatters::Pretty < ::REXML::Formatters::Default
  # source://rexml//lib/rexml/formatters/pretty.rb#30
  def initialize(indentation = T.unsafe(nil), ie_hack = T.unsafe(nil)); end

  # source://rexml//lib/rexml/formatters/pretty.rb#14
  def compact; end

  # source://rexml//lib/rexml/formatters/pretty.rb#14
  def compact=(_arg0); end

  # source://rexml//lib/rexml/formatters/pretty.rb#16
  def width; end

  # source://rexml//lib/rexml/formatters/pretty.rb#16
  def width=(_arg0); end

  protected

  # source://rexml//lib/rexml/formatters/pretty.rb#102
  def write_cdata(node, output); end

  # source://rexml//lib/rexml/formatters/pretty.rb#97
  def write_comment(node, output); end

  # source://rexml//lib/rexml/formatters/pretty.rb#107
  def write_document(node, output); end

  # source://rexml//lib/rexml/formatters/pretty.rb#39
  def write_element(node, output); end

  # source://rexml//lib/rexml/formatters/pretty.rb#88
  def write_text(node, output); end

  private

  # source://rexml//lib/rexml/formatters/pretty.rb#124
  def indent_text(string, level = T.unsafe(nil), style = T.unsafe(nil), indentfirstline = T.unsafe(nil)); end

  # source://rexml//lib/rexml/formatters/pretty.rb#129
  def wrap(string, width); end
end

# source://rexml//lib/rexml/source.rb#182
class REXML::IOSource < ::REXML::Source
  # source://rexml//lib/rexml/source.rb#186
  def initialize(arg, block_size = T.unsafe(nil), encoding = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#274
  def current_line; end

  # source://rexml//lib/rexml/source.rb#269
  def empty?; end

  # source://rexml//lib/rexml/source.rb#246
  def ensure_buffer; end

  # source://rexml//lib/rexml/source.rb#250
  def match(pattern, cons = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#207
  def read(term = T.unsafe(nil), min_bytes = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#228
  def read_until(term); end

  private

  # source://rexml//lib/rexml/source.rb#316
  def encoding_updated; end

  # source://rexml//lib/rexml/source.rb#296
  def readline(term = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/instruction.rb#9
class REXML::Instruction < ::REXML::Child
  # source://rexml//lib/rexml/instruction.rb#25
  def initialize(target, content = T.unsafe(nil)); end

  # source://rexml//lib/rexml/instruction.rb#65
  def ==(other); end

  # source://rexml//lib/rexml/instruction.rb#44
  def clone; end

  # source://rexml//lib/rexml/instruction.rb#15
  def content; end

  # source://rexml//lib/rexml/instruction.rb#15
  def content=(_arg0); end

  # source://rexml//lib/rexml/instruction.rb#75
  def inspect; end

  # source://rexml//lib/rexml/instruction.rb#71
  def node_type; end

  # source://rexml//lib/rexml/instruction.rb#15
  def target; end

  # source://rexml//lib/rexml/instruction.rb#15
  def target=(_arg0); end

  # source://rexml//lib/rexml/instruction.rb#51
  def write(writer, indent = T.unsafe(nil), transitive = T.unsafe(nil), ie_hack = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/namespace.rb#7
module REXML::Namespace
  include ::REXML::XMLTokens

  # source://rexml//lib/rexml/namespace.rb#9
  def expanded_name; end

  # source://rexml//lib/rexml/namespace.rb#57
  def fully_expanded_name; end

  # source://rexml//lib/rexml/namespace.rb#43
  def has_name?(other, ns = T.unsafe(nil)); end

  # source://rexml//lib/rexml/namespace.rb#9
  def name; end

  # source://rexml//lib/rexml/namespace.rb#17
  def name=(name); end

  # source://rexml//lib/rexml/namespace.rb#11
  def prefix; end

  # source://rexml//lib/rexml/namespace.rb#11
  def prefix=(_arg0); end
end

# source://rexml//lib/rexml/namespace.rb#13
REXML::Namespace::NAME_WITHOUT_NAMESPACE = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/doctype.rb#280
class REXML::NotationDecl < ::REXML::Child
  # source://rexml//lib/rexml/doctype.rb#282
  def initialize(name, middle, pub, sys); end

  # source://rexml//lib/rexml/doctype.rb#307
  def name; end

  # source://rexml//lib/rexml/doctype.rb#281
  def public; end

  # source://rexml//lib/rexml/doctype.rb#281
  def public=(_arg0); end

  # source://rexml//lib/rexml/doctype.rb#281
  def system; end

  # source://rexml//lib/rexml/doctype.rb#281
  def system=(_arg0); end

  # source://rexml//lib/rexml/doctype.rb#290
  def to_s; end

  # source://rexml//lib/rexml/doctype.rb#300
  def write(output, indent = T.unsafe(nil)); end
end

# source://rexml//lib/rexml/output.rb#5
class REXML::Output
  include ::REXML::Encoding

  # source://rexml//lib/rexml/output.rb#10
  def initialize(real_IO, encd = T.unsafe(nil)); end

  # source://rexml//lib/rexml/output.rb#22
  def <<(content); end

  # source://rexml//lib/rexml/output.rb#8
  def encoding; end

  # source://rexml//lib/rexml/output.rb#26
  def to_s; end
end

# source://rexml//lib/rexml/parent.rb#8
class REXML::Parent < ::REXML::Child
  include ::Enumerable

  # source://rexml//lib/rexml/parent.rb#13
  def initialize(parent = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parent.rb#18
  def <<(object); end

  # source://rexml//lib/rexml/parent.rb#57
  def [](index); end

  # source://rexml//lib/rexml/parent.rb#70
  def []=(*args); end

  # source://rexml//lib/rexml/parent.rb#18
  def add(object); end

  # source://rexml//lib/rexml/parent.rb#115
  def children; end

  # source://rexml//lib/rexml/parent.rb#148
  def deep_clone; end

  # source://rexml//lib/rexml/parent.rb#32
  def delete(object); end

  # source://rexml//lib/rexml/parent.rb#47
  def delete_at(index); end

  # source://rexml//lib/rexml/parent.rb#43
  def delete_if(&block); end

  # source://rexml//lib/rexml/parent.rb#39
  def each(&block); end

  # source://rexml//lib/rexml/parent.rb#39
  def each_child(&block); end

  # source://rexml//lib/rexml/parent.rb#51
  def each_index(&block); end

  # source://rexml//lib/rexml/parent.rb#123
  def index(child); end

  # source://rexml//lib/rexml/parent.rb#102
  def insert_after(child1, child2); end

  # source://rexml//lib/rexml/parent.rb#82
  def insert_before(child1, child2); end

  # source://rexml//lib/rexml/parent.rb#130
  def length; end

  # source://rexml//lib/rexml/parent.rb#162
  def parent?; end

  # source://rexml//lib/rexml/parent.rb#18
  def push(object); end

  # source://rexml//lib/rexml/parent.rb#140
  def replace_child(to_replace, replacement); end

  # source://rexml//lib/rexml/parent.rb#130
  def size; end

  # source://rexml//lib/rexml/parent.rb#115
  def to_a; end

  # source://rexml//lib/rexml/parent.rb#27
  def unshift(object); end
end

# source://rexml//lib/rexml/parseexception.rb#3
class REXML::ParseException < ::RuntimeError
  # source://rexml//lib/rexml/parseexception.rb#6
  def initialize(message, source = T.unsafe(nil), parser = T.unsafe(nil), exception = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parseexception.rb#49
  def context; end

  # source://rexml//lib/rexml/parseexception.rb#4
  def continued_exception; end

  # source://rexml//lib/rexml/parseexception.rb#4
  def continued_exception=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#44
  def line; end

  # source://rexml//lib/rexml/parseexception.rb#4
  def parser; end

  # source://rexml//lib/rexml/parseexception.rb#4
  def parser=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#39
  def position; end

  # source://rexml//lib/rexml/parseexception.rb#4
  def source; end

  # source://rexml//lib/rexml/parseexception.rb#4
  def source=(_arg0); end

  # source://rexml//lib/rexml/parseexception.rb#13
  def to_s; end
end

# source://rexml//lib/rexml/parsers/baseparser.rb#41
class REXML::Parsers::BaseParser
  # source://rexml//lib/rexml/parsers/baseparser.rb#145
  def initialize(source); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#152
  def add_listener(listener); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#180
  def empty?; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#507
  def entity(reference, entities); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#157
  def entity_expansion_count; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#185
  def has_next?; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#520
  def normalize(input, entities = T.unsafe(nil), entity_filter = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#201
  def peek(depth = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#170
  def position; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#216
  def pull; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#156
  def source; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#159
  def stream=(source); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#536
  def unnormalize(string, entities = T.unsafe(nil), filter = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#191
  def unshift(token); end

  private

  # source://rexml//lib/rexml/parsers/baseparser.rb#582
  def need_source_encoding_update?(xml_declaration_encoding); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#702
  def parse_attributes(prefixes, curr_ns); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#601
  def parse_id(base_error_message, accept_external_id:, accept_public_id:); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#629
  def parse_id_invalid_details(accept_external_id:, accept_public_id:); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#588
  def parse_name(base_error_message); end

  # source://rexml//lib/rexml/parsers/baseparser.rb#667
  def process_instruction; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#226
  def pull_event; end

  # source://rexml//lib/rexml/parsers/baseparser.rb#575
  def record_entity_expansion; end
end

# source://rexml//lib/rexml/parsers/baseparser.rb#114
REXML::Parsers::BaseParser::EXTERNAL_ID_PUBLIC = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#115
REXML::Parsers::BaseParser::EXTERNAL_ID_SYSTEM = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#116
REXML::Parsers::BaseParser::PUBLIC_ID = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#127
module REXML::Parsers::BaseParser::Private; end

# source://rexml//lib/rexml/parsers/baseparser.rb#130
REXML::Parsers::BaseParser::Private::ATTLISTDECL_END = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#135
REXML::Parsers::BaseParser::Private::CARRIAGE_RETURN_NEWLINE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#136
REXML::Parsers::BaseParser::Private::CHARACTER_REFERENCES = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#129
REXML::Parsers::BaseParser::Private::CLOSE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#137
REXML::Parsers::BaseParser::Private::DEFAULT_ENTITIES_PATTERNS = T.let(T.unsafe(nil), Hash)

# source://rexml//lib/rexml/parsers/baseparser.rb#134
REXML::Parsers::BaseParser::Private::ENTITYDECL_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#132
REXML::Parsers::BaseParser::Private::GEDECL_PATTERN = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/parsers/baseparser.rb#131
REXML::Parsers::BaseParser::Private::NAME_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#133
REXML::Parsers::BaseParser::Private::PEDECL_PATTERN = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/parsers/baseparser.rb#128
REXML::Parsers::BaseParser::Private::TAG_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#50
REXML::Parsers::BaseParser::QNAME = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/baseparser.rb#49
REXML::Parsers::BaseParser::QNAME_STR = T.let(T.unsafe(nil), String)

# source://rexml//lib/rexml/parsers/streamparser.rb#6
class REXML::Parsers::StreamParser
  # source://rexml//lib/rexml/parsers/streamparser.rb#7
  def initialize(source, listener); end

  # source://rexml//lib/rexml/parsers/streamparser.rb#13
  def add_listener(listener); end

  # source://rexml//lib/rexml/parsers/streamparser.rb#17
  def parse; end
end

# source://rexml//lib/rexml/parsers/treeparser.rb#7
class REXML::Parsers::TreeParser
  # source://rexml//lib/rexml/parsers/treeparser.rb#8
  def initialize(source, build_context = T.unsafe(nil)); end

  # source://rexml//lib/rexml/parsers/treeparser.rb#13
  def add_listener(listener); end

  # source://rexml//lib/rexml/parsers/treeparser.rb#17
  def parse; end
end

# source://rexml//lib/rexml/parsers/xpathparser.rb#12
class REXML::Parsers::XPathParser
  include ::REXML::XMLTokens

  # source://rexml//lib/rexml/parsers/xpathparser.rb#42
  def abbreviate(path_or_parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#132
  def expand(path_or_parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#16
  def namespaces=(namespaces); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#21
  def parse(path); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#174
  def preciate_to_string(parsed, &block); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#36
  def predicate(path); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#174
  def predicate_to_path(parsed, &block); end

  private

  # source://rexml//lib/rexml/parsers/xpathparser.rb#505
  def AdditiveExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#438
  def AndExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#457
  def EqualityExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#608
  def FilterExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#663
  def FunctionCall(rest, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#243
  def LocationPath(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#528
  def MultiplicativeExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#343
  def NodeTest(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#419
  def OrExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#590
  def PathExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#395
  def Predicate(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#626
  def PrimaryExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#480
  def RelationalExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#267
  def RelativeLocationPath(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#553
  def UnaryExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#571
  def UnionExpr(path, parsed); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#676
  def get_group(string); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#694
  def parse_args(string); end

  # source://rexml//lib/rexml/parsers/xpathparser.rb#224
  def quote_literal(literal); end
end

# source://rexml//lib/rexml/parsers/xpathparser.rb#339
REXML::Parsers::XPathParser::LOCAL_NAME_WILDCARD = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/parsers/xpathparser.rb#338
REXML::Parsers::XPathParser::PREFIX_WILDCARD = T.let(T.unsafe(nil), Regexp)

# source://rexml//lib/rexml/doctype.rb#10
class REXML::ReferenceWriter
  # source://rexml//lib/rexml/doctype.rb#11
  def initialize(id_type, public_id_literal, system_literal, context = T.unsafe(nil)); end

  # source://rexml//lib/rexml/doctype.rb#25
  def write(output); end
end

# source://rexml//lib/rexml/source.rb#51
class REXML::Source
  include ::REXML::Encoding

  # source://rexml//lib/rexml/source.rb#71
  def initialize(arg, encoding = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#83
  def buffer; end

  # source://rexml//lib/rexml/source.rb#93
  def buffer_encoding=(encoding); end

  # source://rexml//lib/rexml/source.rb#142
  def current_line; end

  # source://rexml//lib/rexml/source.rb#87
  def drop_parsed_content; end

  # source://rexml//lib/rexml/source.rb#137
  def empty?; end

  # source://rexml//lib/rexml/source.rb#55
  def encoding; end

  # source://rexml//lib/rexml/source.rb#99
  def encoding=(enc); end

  # source://rexml//lib/rexml/source.rb#117
  def ensure_buffer; end

  # source://rexml//lib/rexml/source.rb#54
  def line; end

  # source://rexml//lib/rexml/source.rb#120
  def match(pattern, cons = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#128
  def position; end

  # source://rexml//lib/rexml/source.rb#132
  def position=(pos); end

  # source://rexml//lib/rexml/source.rb#104
  def read(term = T.unsafe(nil)); end

  # source://rexml//lib/rexml/source.rb#107
  def read_until(term); end

  private

  # source://rexml//lib/rexml/source.rb#151
  def detect_encoding; end

  # source://rexml//lib/rexml/source.rb#169
  def encoding_updated; end
end

# source://rexml//lib/rexml/source.rb#57
module REXML::Source::Private; end

# source://rexml//lib/rexml/source.rb#59
REXML::Source::Private::PRE_DEFINED_TERM_PATTERNS = T.let(T.unsafe(nil), Hash)

# source://rexml//lib/rexml/source.rb#58
REXML::Source::Private::SCANNER_RESET_SIZE = T.let(T.unsafe(nil), Integer)

# source://rexml//lib/rexml/text.rb#11
class REXML::Text < ::REXML::Child
  include ::Comparable

  # source://rexml//lib/rexml/text.rb#94
  def initialize(arg, respect_whitespace = T.unsafe(nil), parent = T.unsafe(nil), raw = T.unsafe(nil), entity_filter = T.unsafe(nil), illegal = T.unsafe(nil)); end

  # source://rexml//lib/rexml/text.rb#214
  def <<(to_append); end

  # source://rexml//lib/rexml/text.rb#223
  def <=>(other); end

  # source://rexml//lib/rexml/text.rb#204
  def clone; end

  # source://rexml//lib/rexml/text.rb#227
  def doctype; end

  # source://rexml//lib/rexml/text.rb#199
  def empty?; end

  # source://rexml//lib/rexml/text.rb#298
  def indent_text(string, level = T.unsafe(nil), style = T.unsafe(nil), indentfirstline = T.unsafe(nil)); end

  # source://rexml//lib/rexml/text.rb#253
  def inspect; end

  # source://rexml//lib/rexml/text.rb#195
  def node_type; end

  # source://rexml//lib/rexml/text.rb#125
  def parent=(parent); end

  # source://rexml//lib/rexml/text.rb#21
  def raw; end

  # source://rexml//lib/rexml/text.rb#21
  def raw=(_arg0); end

  # source://rexml//lib/rexml/text.rb#248
  def to_s; end

  # source://rexml//lib/rexml/text.rb#270
  def value; end

  # source://rexml//lib/rexml/text.rb#281
  def value=(val); end

  # source://rexml//lib/rexml/text.rb#287
  def wrap(string, width, addnewline = T.unsafe(nil)); end

  # source://rexml//lib/rexml/text.rb#313
  def write(writer, indent = T.unsafe(nil), transitive = T.unsafe(nil), ie_hack = T.unsafe(nil)); end

  # source://rexml//lib/rexml/text.rb#345
  def write_with_substitution(out, input); end

  # source://rexml//lib/rexml/text.rb#325
  def xpath; end

  private

  # source://rexml//lib/rexml/text.rb#358
  def clear_cache; end

  class << self
    # source://rexml//lib/rexml/text.rb#131
    def check(string, pattern, doctype); end

    # source://rexml//lib/rexml/text.rb#427
    def expand(ref, doctype, filter); end

    # source://rexml//lib/rexml/text.rb#390
    def normalize(input, doctype = T.unsafe(nil), entity_filter = T.unsafe(nil)); end

    # source://rexml//lib/rexml/text.rb#364
    def read_with_substitution(input, illegal = T.unsafe(nil)); end

    # source://rexml//lib/rexml/text.rb#414
    def unnormalize(string, doctype = T.unsafe(nil), filter = T.unsafe(nil), illegal = T.unsafe(nil)); end
  end
end

# source://rexml//lib/rexml/undefinednamespaceexception.rb#4
class REXML::UndefinedNamespaceException < ::REXML::ParseException
  # source://rexml//lib/rexml/undefinednamespaceexception.rb#5
  def initialize(prefix, source, parser); end
end

# source://rexml//lib/rexml/validation/validationexception.rb#4
class REXML::Validation::ValidationException < ::RuntimeError
  # source://rexml//lib/rexml/validation/validationexception.rb#5
  def initialize(msg); end
end

# source://rexml//lib/rexml/xmldecl.rb#8
class REXML::XMLDecl < ::REXML::Child
  include ::REXML::Encoding

  # source://rexml//lib/rexml/xmldecl.rb#20
  def initialize(version = T.unsafe(nil), encoding = T.unsafe(nil), standalone = T.unsafe(nil)); end

  # source://rexml//lib/rexml/xmldecl.rb#56
  def ==(other); end

  # source://rexml//lib/rexml/xmldecl.rb#39
  def clone; end

  # source://rexml//lib/rexml/xmldecl.rb#102
  def dowrite; end

  # source://rexml//lib/rexml/xmldecl.rb#76
  def encoding=(enc); end

  # source://rexml//lib/rexml/xmldecl.rb#106
  def inspect; end

  # source://rexml//lib/rexml/xmldecl.rb#69
  def node_type; end

  # source://rexml//lib/rexml/xmldecl.rb#98
  def nowrite; end

  # source://rexml//lib/rexml/encoding.rb#7
  def old_enc=(encoding); end

  # source://rexml//lib/rexml/xmldecl.rb#17
  def stand_alone?; end

  # source://rexml//lib/rexml/xmldecl.rb#17
  def standalone; end

  # source://rexml//lib/rexml/xmldecl.rb#17
  def standalone=(_arg0); end

  # source://rexml//lib/rexml/xmldecl.rb#17
  def version; end

  # source://rexml//lib/rexml/xmldecl.rb#17
  def version=(_arg0); end

  # source://rexml//lib/rexml/xmldecl.rb#49
  def write(writer, indent = T.unsafe(nil), transitive = T.unsafe(nil), ie_hack = T.unsafe(nil)); end

  # source://rexml//lib/rexml/xmldecl.rb#18
  def writeencoding; end

  # source://rexml//lib/rexml/xmldecl.rb#18
  def writethis; end

  # source://rexml//lib/rexml/xmldecl.rb#63
  def xmldecl(version, encoding, standalone); end

  private

  # source://rexml//lib/rexml/xmldecl.rb#111
  def content(enc); end

  class << self
    # source://rexml//lib/rexml/xmldecl.rb#92
    def default; end
  end
end

# source://rexml//lib/rexml/xpath_parser.rb#963
class REXML::XPathNode
  # source://rexml//lib/rexml/xpath_parser.rb#965
  def initialize(node, context = T.unsafe(nil)); end

  # source://rexml//lib/rexml/xpath_parser.rb#964
  def context; end

  # source://rexml//lib/rexml/xpath_parser.rb#974
  def position; end

  # source://rexml//lib/rexml/xpath_parser.rb#964
  def raw_node; end
end

# source://rexml//lib/rexml/xpath_parser.rb#54
class REXML::XPathParser
  include ::REXML::XMLTokens

  # source://rexml//lib/rexml/xpath_parser.rb#60
  def initialize(strict: T.unsafe(nil)); end

  # source://rexml//lib/rexml/xpath_parser.rb#94
  def []=(variable_name, value); end

  # source://rexml//lib/rexml/xpath_parser.rb#103
  def first(path_stack, node); end

  # source://rexml//lib/rexml/xpath_parser.rb#84
  def get_first(path, nodeset); end

  # source://rexml//lib/rexml/xpath_parser.rb#139
  def match(path_stack, nodeset); end

  # source://rexml//lib/rexml/xpath_parser.rb#69
  def namespaces=(namespaces = T.unsafe(nil)); end

  # source://rexml//lib/rexml/xpath_parser.rb#79
  def parse(path, nodeset); end

  # source://rexml//lib/rexml/xpath_parser.rb#89
  def predicate(path, nodeset); end

  # source://rexml//lib/rexml/xpath_parser.rb#74
  def variables=(vars = T.unsafe(nil)); end

  private

  # source://rexml//lib/rexml/xpath_parser.rb#779
  def child(nodeset); end

  # source://rexml//lib/rexml/xpath_parser.rb#920
  def compare(a, operator, b); end

  # source://rexml//lib/rexml/xpath_parser.rb#682
  def descendant(nodeset, include_self); end

  # source://rexml//lib/rexml/xpath_parser.rb#693
  def descendant_recursive(raw_node, new_nodeset, new_nodes, include_self); end

  # source://rexml//lib/rexml/xpath_parser.rb#942
  def each_unnode(nodeset); end

  # source://rexml//lib/rexml/xpath_parser.rb#641
  def enter(tag, *args); end

  # source://rexml//lib/rexml/xpath_parser.rb#819
  def equality_relational_compare(set1, op, set2); end

  # source://rexml//lib/rexml/xpath_parser.rb#591
  def evaluate_predicate(expression, nodesets); end

  # source://rexml//lib/rexml/xpath_parser.rb#175
  def expr(path_stack, nodeset, context = T.unsafe(nil)); end

  # source://rexml//lib/rexml/xpath_parser.rb#582
  def filter_nodeset(nodeset); end

  # source://rexml//lib/rexml/xpath_parser.rb#749
  def following(node); end

  # source://rexml//lib/rexml/xpath_parser.rb#760
  def following_node_of(node); end

  # source://rexml//lib/rexml/xpath_parser.rb#163
  def get_namespace(node, prefix); end

  # source://rexml//lib/rexml/xpath_parser.rb#646
  def leave(tag, *args); end

  # source://rexml//lib/rexml/xpath_parser.rb#767
  def next_sibling_node(node); end

  # source://rexml//lib/rexml/xpath_parser.rb#477
  def node_test(path_stack, nodesets, any_type: T.unsafe(nil)); end

  # source://rexml//lib/rexml/xpath_parser.rb#806
  def norm(b); end

  # source://rexml//lib/rexml/xpath_parser.rb#894
  def normalize_compare_values(a, operator, b); end

  # source://rexml//lib/rexml/xpath_parser.rb#712
  def preceding(node); end

  # source://rexml//lib/rexml/xpath_parser.rb#734
  def preceding_node_of(node); end

  # source://rexml//lib/rexml/xpath_parser.rb#659
  def sort(array_of_nodes, order); end

  # source://rexml//lib/rexml/xpath_parser.rb#441
  def step(path_stack, any_type: T.unsafe(nil), order: T.unsafe(nil)); end

  # source://rexml//lib/rexml/xpath_parser.rb#154
  def strict?; end

  # source://rexml//lib/rexml/xpath_parser.rb#634
  def trace(*args); end

  # source://rexml//lib/rexml/xpath_parser.rb#954
  def unnode(nodeset); end

  # source://rexml//lib/rexml/xpath_parser.rb#881
  def value_type(value); end
end

# source://rexml//lib/rexml/xpath_parser.rb#58
REXML::XPathParser::DEBUG = T.let(T.unsafe(nil), FalseClass)
