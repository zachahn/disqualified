# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `actioncable` gem.
# Please instead update this file by running `bin/tapioca gem actioncable`.


# source://actioncable//lib/action_cable.rb#54
module ActionCable
  private

  # source://actioncable//lib/action_cable.rb#77
  def server; end

  class << self
    # source://actioncable//lib/action_cable/deprecator.rb#6
    def deprecator; end

    # source://actioncable//lib/action_cable/gem_version.rb#7
    def gem_version; end

    # source://actioncable//lib/action_cable.rb#77
    def server; end

    # source://actioncable//lib/action_cable/version.rb#9
    def version; end
  end
end

# source://actioncable//lib/action_cable/channel/base.rb#10
module ActionCable::Channel; end

# source://actioncable//lib/action_cable/channel/base.rb#110
class ActionCable::Channel::Base
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Channel::Callbacks
  include ::ActionCable::Channel::PeriodicTimers
  include ::ActionCable::Channel::Streams
  include ::ActionCable::Channel::Naming
  include ::ActionCable::Channel::Broadcasting
  include ::ActiveSupport::Rescuable
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Channel::Callbacks::ClassMethods
  extend ::ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::ActionCable::Channel::Naming::ClassMethods
  extend ::ActionCable::Channel::Broadcasting::ClassMethods
  extend ::ActiveSupport::Rescuable::ClassMethods

  # source://actioncable//lib/action_cable/channel/base.rb#156
  def initialize(connection, identifier, params = T.unsafe(nil)); end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#912
  def _run_subscribe_callbacks(&block); end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#912
  def _run_unsubscribe_callbacks(&block); end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#924
  def _subscribe_callbacks; end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#924
  def _unsubscribe_callbacks; end

  # source://actioncable//lib/action_cable/channel/base.rb#118
  def connection; end

  # source://actioncable//lib/action_cable/channel/base.rb#118
  def identifier; end

  # source://actioncable//lib/action_cable/channel/base.rb#119
  def logger(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/channel/base.rb#118
  def params; end

  # source://actioncable//lib/action_cable/channel/base.rb#176
  def perform_action(data); end

  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#11
  def periodic_timers=(_arg0); end

  # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
  def rescue_handlers; end

  # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
  def rescue_handlers=(_arg0); end

  # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
  def rescue_handlers?; end

  # source://actioncable//lib/action_cable/channel/base.rb#191
  def subscribe_to_channel; end

  # source://actioncable//lib/action_cable/channel/base.rb#203
  def unsubscribe_from_channel; end

  private

  # source://actioncable//lib/action_cable/channel/base.rb#293
  def action_signature(action, data); end

  # source://actioncable//lib/action_cable/channel/base.rb#245
  def defer_subscription_confirmation!; end

  # source://actioncable//lib/action_cable/channel/base.rb#249
  def defer_subscription_confirmation?; end

  # source://actioncable//lib/action_cable/channel/base.rb#265
  def delegate_connection_identifiers; end

  # source://actioncable//lib/action_cable/channel/base.rb#281
  def dispatch_action(action, data); end

  # source://actioncable//lib/action_cable/channel/base.rb#239
  def ensure_confirmation_sent; end

  # source://actioncable//lib/action_cable/channel/base.rb#273
  def extract_action(data); end

  # source://actioncable//lib/action_cable/channel/base.rb#304
  def parameter_filter; end

  # source://actioncable//lib/action_cable/channel/base.rb#277
  def processable_action?(action); end

  # source://actioncable//lib/action_cable/channel/base.rb#257
  def reject; end

  # source://actioncable//lib/action_cable/channel/base.rb#319
  def reject_subscription; end

  # source://actioncable//lib/action_cable/channel/base.rb#213
  def subscribed; end

  # source://actioncable//lib/action_cable/channel/base.rb#253
  def subscription_confirmation_sent?; end

  # source://actioncable//lib/action_cable/channel/base.rb#261
  def subscription_rejected?; end

  # source://actioncable//lib/action_cable/channel/base.rb#226
  def transmit(data, via: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/base.rb#308
  def transmit_subscription_confirmation; end

  # source://actioncable//lib/action_cable/channel/base.rb#324
  def transmit_subscription_rejection; end

  # source://actioncable//lib/action_cable/channel/base.rb#219
  def unsubscribed; end

  class << self
    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#916
    def _subscribe_callbacks; end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#920
    def _subscribe_callbacks=(value); end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#916
    def _unsubscribe_callbacks; end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#920
    def _unsubscribe_callbacks=(value); end

    # source://actioncable//lib/action_cable/channel/base.rb#129
    def action_methods; end

    # source://actioncable//lib/action_cable/channel/periodic_timers.rb#11
    def periodic_timers; end

    # source://actioncable//lib/action_cable/channel/periodic_timers.rb#11
    def periodic_timers=(value); end

    # source://actioncable//lib/action_cable/channel/periodic_timers.rb#11
    def periodic_timers?; end

    # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
    def rescue_handlers; end

    # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
    def rescue_handlers=(value); end

    # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
    def rescue_handlers?; end

    private

    # source://actioncable//lib/action_cable/channel/base.rb#145
    def clear_action_methods!; end

    # source://actioncable//lib/action_cable/channel/base.rb#150
    def method_added(name); end
  end
end

# source://actioncable//lib/action_cable/channel/broadcasting.rb#9
module ActionCable::Channel::Broadcasting
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionCable::Channel::Broadcasting::ClassMethods

  # source://actioncable//lib/action_cable/channel/broadcasting.rb#45
  def broadcast_to(model, message); end

  # source://actioncable//lib/action_cable/channel/broadcasting.rb#41
  def broadcasting_for(model); end
end

# source://actioncable//lib/action_cable/channel/broadcasting.rb#12
module ActionCable::Channel::Broadcasting::ClassMethods
  # source://actioncable//lib/action_cable/channel/broadcasting.rb#14
  def broadcast_to(model, message); end

  # source://actioncable//lib/action_cable/channel/broadcasting.rb#24
  def broadcasting_for(model); end

  private

  # source://actioncable//lib/action_cable/channel/broadcasting.rb#29
  def serialize_broadcasting(object); end
end

# source://actioncable//lib/action_cable/channel/callbacks.rb#38
module ActionCable::Channel::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActionCable::Channel::Callbacks::ClassMethods

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

# source://actioncable//lib/action_cable/channel/callbacks.rb#47
module ActionCable::Channel::Callbacks::ClassMethods
  # source://actioncable//lib/action_cable/channel/callbacks.rb#60
  def after_subscribe(*methods, &block); end

  # source://actioncable//lib/action_cable/channel/callbacks.rb#69
  def after_unsubscribe(*methods, &block); end

  # source://actioncable//lib/action_cable/channel/callbacks.rb#48
  def before_subscribe(*methods, &block); end

  # source://actioncable//lib/action_cable/channel/callbacks.rb#65
  def before_unsubscribe(*methods, &block); end

  # source://actioncable//lib/action_cable/channel/callbacks.rb#60
  def on_subscribe(*methods, &block); end

  # source://actioncable//lib/action_cable/channel/callbacks.rb#69
  def on_unsubscribe(*methods, &block); end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#24
module ActionCable::Channel::ChannelStub
  # source://actioncable//lib/action_cable/channel/test_case.rb#25
  def confirmed?; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#29
  def rejected?; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#46
  def start_periodic_timers; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#37
  def stop_all_streams; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#46
  def stop_periodic_timers; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#33
  def stream_from(broadcasting, *_arg1); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#41
  def streams; end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#50
class ActionCable::Channel::ConnectionStub
  # source://actioncable//lib/action_cable/channel/test_case.rb#55
  def initialize(identifiers = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#53
  def config(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#72
  def connection_identifier; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#51
  def identifiers; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#51
  def logger; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#53
  def pubsub(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#51
  def server; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#51
  def subscriptions; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#51
  def transmissions; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#68
  def transmit(cable_message); end

  private

  # source://actioncable//lib/action_cable/channel/test_case.rb#77
  def connection_gid(ids); end
end

# source://actioncable//lib/action_cable/channel/naming.rb#7
module ActionCable::Channel::Naming
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionCable::Channel::Naming::ClassMethods

  # source://actioncable//lib/action_cable/channel/naming.rb#23
  def channel_name; end
end

# source://actioncable//lib/action_cable/channel/naming.rb#10
module ActionCable::Channel::Naming::ClassMethods
  # source://actioncable//lib/action_cable/channel/naming.rb#18
  def channel_name; end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#12
class ActionCable::Channel::NonInferrableChannelError < ::StandardError
  # source://actioncable//lib/action_cable/channel/test_case.rb#13
  def initialize(name); end
end

# source://actioncable//lib/action_cable/channel/periodic_timers.rb#7
module ActionCable::Channel::PeriodicTimers
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionCable::Channel::PeriodicTimers::ClassMethods

  private

  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#56
  def active_periodic_timers; end

  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#66
  def start_periodic_timer(callback, every:); end

  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#60
  def start_periodic_timers; end

  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#72
  def stop_periodic_timers; end

  module GeneratedClassMethods
    def periodic_timers; end
    def periodic_timers=(value); end
    def periodic_timers?; end
  end

  module GeneratedInstanceMethods
    def periodic_timers=(value); end
  end
end

# source://actioncable//lib/action_cable/channel/periodic_timers.rb#17
module ActionCable::Channel::PeriodicTimers::ClassMethods
  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#31
  def periodically(callback_or_method_name = T.unsafe(nil), every:, &block); end
end

# source://actioncable//lib/action_cable/channel/streams.rb#77
module ActionCable::Channel::Streams
  extend ::ActiveSupport::Concern

  # source://actioncable//lib/action_cable/channel/streams.rb#153
  def pubsub(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/channel/streams.rb#135
  def stop_all_streams; end

  # source://actioncable//lib/action_cable/channel/streams.rb#130
  def stop_stream_for(model); end

  # source://actioncable//lib/action_cable/channel/streams.rb#121
  def stop_stream_from(broadcasting); end

  # source://actioncable//lib/action_cable/channel/streams.rb#116
  def stream_for(model, callback = T.unsafe(nil), coder: T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/channel/streams.rb#90
  def stream_from(broadcasting, callback = T.unsafe(nil), coder: T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/channel/streams.rb#144
  def stream_or_reject_for(model); end

  private

  # source://actioncable//lib/action_cable/channel/streams.rb#189
  def default_stream_handler(broadcasting, coder:); end

  # source://actioncable//lib/action_cable/channel/streams.rb#210
  def identity_handler; end

  # source://actioncable//lib/action_cable/channel/streams.rb#194
  def stream_decoder(handler = T.unsafe(nil), coder:); end

  # source://actioncable//lib/action_cable/channel/streams.rb#173
  def stream_handler(broadcasting, user_handler, coder: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/streams.rb#202
  def stream_transmitter(handler = T.unsafe(nil), broadcasting:); end

  # source://actioncable//lib/action_cable/channel/streams.rb#155
  def streams; end

  # source://actioncable//lib/action_cable/channel/streams.rb#161
  def worker_pool_stream_handler(broadcasting, user_handler, coder: T.unsafe(nil)); end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#190
class ActionCable::Channel::TestCase < ::ActiveSupport::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::TestHelper
  include ::ActionCable::Channel::TestCase::Behavior
  extend ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  extend ::ActionCable::Channel::TestCase::Behavior::ClassMethods

  # source://actioncable//lib/action_cable/channel/test_case.rb#200
  def _channel_class; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#200
  def _channel_class=(_arg0); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#200
  def _channel_class?; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#202
  def connection; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#202
  def subscription; end

  class << self
    # source://actioncable//lib/action_cable/channel/test_case.rb#200
    def _channel_class; end

    # source://actioncable//lib/action_cable/channel/test_case.rb#200
    def _channel_class=(value); end

    # source://actioncable//lib/action_cable/channel/test_case.rb#200
    def _channel_class?; end
  end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#191
module ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Testing::ConstantLookup

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionCable::Channel::TestCase::Behavior::ClassMethods

  # source://actioncable//lib/action_cable/channel/test_case.rb#282
  def assert_broadcast_on(stream_or_object, *args); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#278
  def assert_broadcasts(stream_or_object, *args); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#326
  def assert_has_no_stream(stream); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#337
  def assert_has_no_stream_for(object); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#304
  def assert_has_stream(stream); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#315
  def assert_has_stream_for(object); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#293
  def assert_no_streams; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#266
  def perform(action, data = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#243
  def stub_connection(identifiers = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#249
  def subscribe(params = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#272
  def transmissions; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#258
  def unsubscribe; end

  private

  # source://actioncable//lib/action_cable/channel/test_case.rb#346
  def broadcasting_for(stream_or_object); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#342
  def check_subscribed!; end

  module GeneratedClassMethods
    def _channel_class; end
    def _channel_class=(value); end
    def _channel_class?; end
  end

  module GeneratedInstanceMethods
    def _channel_class; end
    def _channel_class=(value); end
    def _channel_class?; end
  end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#197
ActionCable::Channel::TestCase::Behavior::CHANNEL_IDENTIFIER = T.let(T.unsafe(nil), String)

# source://actioncable//lib/action_cable/channel/test_case.rb#207
module ActionCable::Channel::TestCase::Behavior::ClassMethods
  # source://actioncable//lib/action_cable/channel/test_case.rb#219
  def channel_class; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#227
  def determine_default_channel(name); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#208
  def tests(channel); end
end

# source://actioncable//lib/action_cable/connection/identification.rb#8
module ActionCable::Connection; end

# source://actioncable//lib/action_cable/connection/test_case.rb#22
module ActionCable::Connection::Assertions
  # source://actioncable//lib/action_cable/connection/test_case.rb#28
  def assert_reject_connection(&block); end
end

# source://actioncable//lib/action_cable/connection/authorization.rb#7
module ActionCable::Connection::Authorization
  # source://actioncable//lib/action_cable/connection/authorization.rb#12
  def reject_unauthorized_connection; end
end

# source://actioncable//lib/action_cable/connection/authorization.rb#8
class ActionCable::Connection::Authorization::UnauthorizedError < ::StandardError; end

# source://actioncable//lib/action_cable/connection/base.rb#57
class ActionCable::Connection::Base
  include ::ActionCable::Connection::Identification
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Authorization
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Connection::Callbacks
  include ::ActiveSupport::Rescuable
  extend ::ActionCable::Connection::Identification::ClassMethods
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Connection::Callbacks::ClassMethods
  extend ::ActiveSupport::Rescuable::ClassMethods

  # source://actioncable//lib/action_cable/connection/base.rb#67
  def initialize(server, env, coder: T.unsafe(nil)); end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#924
  def _command_callbacks; end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#912
  def _run_command_callbacks(&block); end

  # source://actioncable//lib/action_cable/connection/base.rb#147
  def beat; end

  # source://actioncable//lib/action_cable/connection/base.rb#120
  def close(reason: T.unsafe(nil), reconnect: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/connection/base.rb#65
  def config(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/connection/base.rb#101
  def dispatch_websocket_message(websocket_message); end

  # source://actioncable//lib/action_cable/connection/base.rb#64
  def env; end

  # source://actioncable//lib/action_cable/connection/base.rb#65
  def event_loop(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/connection/base.rb#109
  def handle_channel_command(payload); end

  # source://actioncable//lib/action_cable/connection/identification.rb#13
  def identifiers; end

  # source://actioncable//lib/action_cable/connection/identification.rb#13
  def identifiers=(_arg0); end

  # source://actioncable//lib/action_cable/connection/identification.rb#13
  def identifiers?; end

  # source://actioncable//lib/action_cable/connection/base.rb#168
  def inspect; end

  # source://actioncable//lib/action_cable/connection/base.rb#64
  def logger; end

  # source://actioncable//lib/action_cable/connection/base.rb#164
  def on_close(reason, code); end

  # source://actioncable//lib/action_cable/connection/base.rb#159
  def on_error(message); end

  # source://actioncable//lib/action_cable/connection/base.rb#155
  def on_message(message); end

  # source://actioncable//lib/action_cable/connection/base.rb#151
  def on_open; end

  # source://actioncable//lib/action_cable/connection/base.rb#85
  def process; end

  # source://actioncable//lib/action_cable/connection/base.rb#64
  def protocol; end

  # source://actioncable//lib/action_cable/connection/base.rb#65
  def pubsub(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/connection/base.rb#97
  def receive(websocket_message); end

  # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
  def rescue_handlers; end

  # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
  def rescue_handlers=(_arg0); end

  # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
  def rescue_handlers?; end

  # source://actioncable//lib/action_cable/connection/base.rb#131
  def send_async(method, *arguments); end

  # source://actioncable//lib/action_cable/connection/base.rb#64
  def server; end

  # source://actioncable//lib/action_cable/connection/base.rb#138
  def statistics; end

  # source://actioncable//lib/action_cable/connection/base.rb#64
  def subscriptions; end

  # source://actioncable//lib/action_cable/connection/base.rb#115
  def transmit(cable_message); end

  # source://actioncable//lib/action_cable/connection/base.rb#64
  def worker_pool; end

  private

  # source://actioncable//lib/action_cable/connection/base.rb#228
  def allow_request_origin?; end

  # source://actioncable//lib/action_cable/connection/base.rb#187
  def cookies; end

  # source://actioncable//lib/action_cable/connection/base.rb#195
  def decode(websocket_message); end

  # source://actioncable//lib/action_cable/connection/base.rb#191
  def encode(cable_message); end

  # source://actioncable//lib/action_cable/connection/base.rb#271
  def finished_request_message; end

  # source://actioncable//lib/action_cable/connection/base.rb#211
  def handle_close; end

  # source://actioncable//lib/action_cable/connection/base.rb#199
  def handle_open; end

  # source://actioncable//lib/action_cable/connection/base.rb#279
  def invalid_request_message; end

  # source://actioncable//lib/action_cable/connection/base.rb#174
  def message_buffer; end

  # source://actioncable//lib/action_cable/connection/base.rb#257
  def new_tagged_logger; end

  # source://actioncable//lib/action_cable/connection/base.rb#178
  def request; end

  # source://actioncable//lib/action_cable/connection/base.rb#247
  def respond_to_invalid_request; end

  # source://actioncable//lib/action_cable/connection/base.rb#242
  def respond_to_successful_request; end

  # source://actioncable//lib/action_cable/connection/base.rb#222
  def send_welcome_message; end

  # source://actioncable//lib/action_cable/connection/base.rb#262
  def started_request_message; end

  # source://actioncable//lib/action_cable/connection/base.rb#285
  def successful_request_message; end

  # source://actioncable//lib/action_cable/connection/base.rb#173
  def websocket; end

  class << self
    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#916
    def _command_callbacks; end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#920
    def _command_callbacks=(value); end

    # source://actioncable//lib/action_cable/connection/identification.rb#13
    def identifiers; end

    # source://actioncable//lib/action_cable/connection/identification.rb#13
    def identifiers=(value); end

    # source://actioncable//lib/action_cable/connection/identification.rb#13
    def identifiers?; end

    # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
    def rescue_handlers; end

    # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
    def rescue_handlers=(value); end

    # source://activesupport/7.2.0/lib/active_support/rescuable.rb#15
    def rescue_handlers?; end
  end
end

# source://actioncable//lib/action_cable/connection/callbacks.rb#34
module ActionCable::Connection::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActionCable::Connection::Callbacks::ClassMethods

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

# source://actioncable//lib/action_cable/connection/callbacks.rb#42
module ActionCable::Connection::Callbacks::ClassMethods
  # source://actioncable//lib/action_cable/connection/callbacks.rb#47
  def after_command(*methods, &block); end

  # source://actioncable//lib/action_cable/connection/callbacks.rb#51
  def around_command(*methods, &block); end

  # source://actioncable//lib/action_cable/connection/callbacks.rb#43
  def before_command(*methods, &block); end
end

# source://actioncable//lib/action_cable/connection/client_socket.rb#13
class ActionCable::Connection::ClientSocket
  # source://actioncable//lib/action_cable/connection/client_socket.rb#36
  def initialize(env, event_target, event_loop, protocols); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#114
  def alive?; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#110
  def client_gone; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#92
  def close(code = T.unsafe(nil), reason = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#34
  def env; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#106
  def parse(data); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#118
  def protocol; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#71
  def rack_response; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#59
  def start_driver; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#82
  def transmit(message); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#34
  def url; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#76
  def write(data); end

  private

  # source://actioncable//lib/action_cable/connection/client_socket.rb#142
  def begin_close(reason, code); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#136
  def emit_error(message); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#151
  def finalize_close; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#123
  def open; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#130
  def receive_message(data); end

  class << self
    # source://actioncable//lib/action_cable/connection/client_socket.rb#14
    def determine_url(env); end

    # source://actioncable//lib/action_cable/connection/client_socket.rb#19
    def secure_request?(env); end
  end
end

# source://actioncable//lib/action_cable/connection/client_socket.rb#32
ActionCable::Connection::ClientSocket::CLOSED = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/connection/client_socket.rb#31
ActionCable::Connection::ClientSocket::CLOSING = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/connection/client_socket.rb#29
ActionCable::Connection::ClientSocket::CONNECTING = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/connection/client_socket.rb#30
ActionCable::Connection::ClientSocket::OPEN = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/connection/identification.rb#9
module ActionCable::Connection::Identification
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionCable::Connection::Identification::ClassMethods

  # source://actioncable//lib/action_cable/connection/identification.rb#31
  def connection_identifier; end

  private

  # source://actioncable//lib/action_cable/connection/identification.rb#40
  def connection_gid(ids); end

  module GeneratedClassMethods
    def identifiers; end
    def identifiers=(value); end
    def identifiers?; end
  end

  module GeneratedInstanceMethods
    def identifiers; end
    def identifiers=(value); end
    def identifiers?; end
  end
end

# source://actioncable//lib/action_cable/connection/identification.rb#16
module ActionCable::Connection::Identification::ClassMethods
  # source://actioncable//lib/action_cable/connection/identification.rb#23
  def identified_by(*identifiers); end
end

# source://actioncable//lib/action_cable/connection/internal_channel.rb#11
module ActionCable::Connection::InternalChannel
  extend ::ActiveSupport::Concern

  private

  # source://actioncable//lib/action_cable/connection/internal_channel.rb#15
  def internal_channel; end

  # source://actioncable//lib/action_cable/connection/internal_channel.rb#36
  def process_internal_message(message); end

  # source://actioncable//lib/action_cable/connection/internal_channel.rb#19
  def subscribe_to_internal_channel; end

  # source://actioncable//lib/action_cable/connection/internal_channel.rb#30
  def unsubscribe_from_internal_channel; end
end

# source://actioncable//lib/action_cable/connection/message_buffer.rb#9
class ActionCable::Connection::MessageBuffer
  # source://actioncable//lib/action_cable/connection/message_buffer.rb#10
  def initialize(connection); end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#15
  def append(message); end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#31
  def process!; end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#27
  def processing?; end

  private

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#48
  def buffer(message); end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#38
  def buffered_messages; end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#37
  def connection; end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#44
  def receive(message); end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#52
  def receive_buffered_messages; end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#40
  def valid?(message); end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#14
class ActionCable::Connection::NonInferrableConnectionError < ::StandardError
  # source://actioncable//lib/action_cable/connection/test_case.rb#15
  def initialize(name); end
end

# source://actioncable//lib/action_cable/connection/stream.rb#11
class ActionCable::Connection::Stream
  # source://actioncable//lib/action_cable/connection/stream.rb#12
  def initialize(event_loop, socket); end

  # source://actioncable//lib/action_cable/connection/stream.rb#28
  def close; end

  # source://actioncable//lib/action_cable/connection/stream.rb#24
  def each(&callback); end

  # source://actioncable//lib/action_cable/connection/stream.rb#72
  def flush_write_buffer; end

  # source://actioncable//lib/action_cable/connection/stream.rb#98
  def hijack_rack_socket; end

  # source://actioncable//lib/action_cable/connection/stream.rb#94
  def receive(data); end

  # source://actioncable//lib/action_cable/connection/stream.rb#33
  def shutdown; end

  # source://actioncable//lib/action_cable/connection/stream.rb#37
  def write(data); end

  private

  # source://actioncable//lib/action_cable/connection/stream.rb#110
  def clean_rack_hijack; end
end

# source://actioncable//lib/action_cable/connection/stream_event_loop.rb#9
class ActionCable::Connection::StreamEventLoop
  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#10
  def initialize; end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#30
  def attach(io, stream); end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#38
  def detach(io, stream); end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#23
  def post(task = T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#56
  def stop; end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#19
  def timer(interval, &block); end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#47
  def writes_pending(io); end

  private

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#86
  def run; end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#62
  def spawn; end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#82
  def wakeup; end
end

# source://actioncable//lib/action_cable/connection/subscriptions.rb#14
class ActionCable::Connection::Subscriptions
  # source://actioncable//lib/action_cable/connection/subscriptions.rb#15
  def initialize(connection); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#33
  def add(data); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#20
  def execute_command(data); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#64
  def identifiers; end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#74
  def logger(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#60
  def perform_action(data); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#50
  def remove(data); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#55
  def remove_subscription(subscription); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#68
  def unsubscribe_from_all; end

  private

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#73
  def connection; end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#76
  def find(data); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#73
  def subscriptions; end
end

# source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#13
class ActionCable::Connection::TaggedLoggerProxy
  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#16
  def initialize(logger, tags:); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#21
  def add_tags(*tags); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#36
  def debug(message = T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#36
  def error(message = T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#36
  def fatal(message = T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#36
  def info(message = T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#26
  def tag(logger, &block); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#14
  def tags; end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#36
  def unknown(message = T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#36
  def warn(message = T.unsafe(nil), &block); end

  private

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#42
  def log(type, message, &block); end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#141
class ActionCable::Connection::TestCase < ::ActiveSupport::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Connection::Assertions
  include ::ActionCable::Connection::TestCase::Behavior
  extend ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  extend ::ActionCable::Connection::TestCase::Behavior::ClassMethods

  # source://actioncable//lib/action_cable/connection/test_case.rb#151
  def _connection_class; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#151
  def _connection_class=(_arg0); end

  # source://actioncable//lib/action_cable/connection/test_case.rb#151
  def _connection_class?; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#153
  def connection; end

  class << self
    # source://actioncable//lib/action_cable/connection/test_case.rb#151
    def _connection_class; end

    # source://actioncable//lib/action_cable/connection/test_case.rb#151
    def _connection_class=(value); end

    # source://actioncable//lib/action_cable/connection/test_case.rb#151
    def _connection_class?; end
  end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#142
module ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Testing::ConstantLookup

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionCable::Connection::TestCase::Behavior::ClassMethods

  # source://actioncable//lib/action_cable/connection/test_case.rb#195
  def connect(path = T.unsafe(nil), **request_params); end

  # source://actioncable//lib/action_cable/connection/test_case.rb#215
  def cookies; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#208
  def disconnect; end

  private

  # source://actioncable//lib/action_cable/connection/test_case.rb#220
  def build_test_request(path, params: T.unsafe(nil), headers: T.unsafe(nil), session: T.unsafe(nil), env: T.unsafe(nil)); end

  module GeneratedClassMethods
    def _connection_class; end
    def _connection_class=(value); end
    def _connection_class?; end
  end

  module GeneratedInstanceMethods
    def _connection_class; end
    def _connection_class=(value); end
    def _connection_class?; end
  end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#158
module ActionCable::Connection::TestCase::Behavior::ClassMethods
  # source://actioncable//lib/action_cable/connection/test_case.rb#170
  def connection_class; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#178
  def determine_default_connection(name); end

  # source://actioncable//lib/action_cable/connection/test_case.rb#159
  def tests(connection); end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#145
ActionCable::Connection::TestCase::Behavior::DEFAULT_PATH = T.let(T.unsafe(nil), String)

# source://actioncable//lib/action_cable/connection/test_case.rb#57
module ActionCable::Connection::TestConnection
  # source://actioncable//lib/action_cable/connection/test_case.rb#60
  def initialize(request); end

  # source://actioncable//lib/action_cable/connection/test_case.rb#58
  def logger; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#58
  def request; end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#43
class ActionCable::Connection::TestCookieJar < ::ActionCable::Connection::TestCookies
  # source://actioncable//lib/action_cable/connection/test_case.rb#48
  def encrypted; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#44
  def signed; end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#33
class ActionCable::Connection::TestCookies < ::ActiveSupport::HashWithIndifferentAccess
  # source://actioncable//lib/action_cable/connection/test_case.rb#34
  def []=(name, options); end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#53
class ActionCable::Connection::TestRequest < ::ActionDispatch::TestRequest
  # source://actioncable//lib/action_cable/connection/test_case.rb#54
  def cookie_jar; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#54
  def cookie_jar=(_arg0); end

  # source://actioncable//lib/action_cable/connection/test_case.rb#54
  def session; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#54
  def session=(_arg0); end
end

# source://actioncable//lib/action_cable/connection/web_socket.rb#12
class ActionCable::Connection::WebSocket
  # source://actioncable//lib/action_cable/connection/web_socket.rb#13
  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#21
  def alive?; end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#29
  def close(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#17
  def possible?; end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#33
  def protocol; end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#37
  def rack_response; end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#25
  def transmit(*_arg0, **_arg1, &_arg2); end

  private

  # source://actioncable//lib/action_cable/connection/web_socket.rb#42
  def websocket; end
end

# source://actioncable//lib/action_cable/engine.rb#10
class ActionCable::Engine < ::Rails::Engine
  class << self
    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
    def __callbacks; end
  end
end

# source://actioncable//lib/action_cable/helpers/action_cable_helper.rb#6
module ActionCable::Helpers; end

# source://actioncable//lib/action_cable/helpers/action_cable_helper.rb#7
module ActionCable::Helpers::ActionCableHelper
  # source://actioncable//lib/action_cable/helpers/action_cable_helper.rb#36
  def action_cable_meta_tag; end
end

# source://actioncable//lib/action_cable.rb#58
ActionCable::INTERNAL = T.let(T.unsafe(nil), Hash)

# source://actioncable//lib/action_cable/remote_connections.rb#31
class ActionCable::RemoteConnections
  # source://actioncable//lib/action_cable/remote_connections.rb#34
  def initialize(server); end

  # source://actioncable//lib/action_cable/remote_connections.rb#32
  def server; end

  # source://actioncable//lib/action_cable/remote_connections.rb#38
  def where(identifier); end
end

# source://actioncable//lib/action_cable/remote_connections.rb#48
class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Identification
  extend ::ActionCable::Connection::Identification::ClassMethods

  # source://actioncable//lib/action_cable/remote_connections.rb#53
  def initialize(server, ids); end

  # source://actioncable//lib/action_cable/remote_connections.rb#59
  def disconnect(reconnect: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/remote_connections.rb#64
  def identifiers; end

  # source://actioncable//lib/action_cable/connection/identification.rb#13
  def identifiers=(_arg0); end

  # source://actioncable//lib/action_cable/connection/identification.rb#13
  def identifiers?; end

  protected

  # source://actioncable//lib/action_cable/remote_connections.rb#69
  def server; end

  private

  # source://actioncable//lib/action_cable/remote_connections.rb#72
  def set_identifier_instance_vars(ids); end

  # source://actioncable//lib/action_cable/remote_connections.rb#77
  def valid_identifiers?(ids); end

  class << self
    # source://actioncable//lib/action_cable/connection/identification.rb#13
    def identifiers; end

    # source://actioncable//lib/action_cable/connection/identification.rb#13
    def identifiers=(value); end

    # source://actioncable//lib/action_cable/connection/identification.rb#13
    def identifiers?; end
  end
end

# source://actioncable//lib/action_cable/remote_connections.rb#49
class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError < ::StandardError; end

# source://actioncable//lib/action_cable/server/base.rb#8
module ActionCable::Server; end

# source://actioncable//lib/action_cable/server/base.rb#18
class ActionCable::Server::Base
  include ::ActionCable::Server::Broadcasting
  include ::ActionCable::Server::Connections

  # source://actioncable//lib/action_cable/server/base.rb#31
  def initialize(config: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/server/base.rb#38
  def call(env); end

  # source://actioncable//lib/action_cable/server/base.rb#24
  def config; end

  # source://actioncable//lib/action_cable/server/base.rb#102
  def connection_identifiers; end

  # source://actioncable//lib/action_cable/server/base.rb#46
  def disconnect(identifiers); end

  # source://actioncable//lib/action_cable/server/base.rb#71
  def event_loop; end

  # source://actioncable//lib/action_cable/server/base.rb#27
  def logger(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/server/base.rb#29
  def mutex; end

  # source://actioncable//lib/action_cable/server/base.rb#96
  def pubsub; end

  # source://actioncable//lib/action_cable/server/base.rb#67
  def remote_connections; end

  # source://actioncable//lib/action_cable/server/base.rb#50
  def restart; end

  # source://actioncable//lib/action_cable/server/base.rb#91
  def worker_pool; end

  class << self
    # source://actioncable//lib/action_cable/server/base.rb#22
    def config; end

    # source://actioncable//lib/action_cable/server/base.rb#22
    def config=(val); end

    # source://actioncable//lib/action_cable/server/base.rb#26
    def logger; end
  end
end

# source://actioncable//lib/action_cable/server/broadcasting.rb#28
module ActionCable::Server::Broadcasting
  # source://actioncable//lib/action_cable/server/broadcasting.rb#31
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/server/broadcasting.rb#38
  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

# source://actioncable//lib/action_cable/server/broadcasting.rb#43
class ActionCable::Server::Broadcasting::Broadcaster
  # source://actioncable//lib/action_cable/server/broadcasting.rb#46
  def initialize(server, broadcasting, coder:); end

  # source://actioncable//lib/action_cable/server/broadcasting.rb#50
  def broadcast(message); end

  # source://actioncable//lib/action_cable/server/broadcasting.rb#44
  def broadcasting; end

  # source://actioncable//lib/action_cable/server/broadcasting.rb#44
  def coder; end

  # source://actioncable//lib/action_cable/server/broadcasting.rb#44
  def server; end
end

# source://actioncable//lib/action_cable/server/configuration.rb#14
class ActionCable::Server::Configuration
  # source://actioncable//lib/action_cable/server/configuration.rb#22
  def initialize; end

  # source://actioncable//lib/action_cable/server/configuration.rb#17
  def allow_same_origin_as_host; end

  # source://actioncable//lib/action_cable/server/configuration.rb#17
  def allow_same_origin_as_host=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#17
  def allowed_request_origins; end

  # source://actioncable//lib/action_cable/server/configuration.rb#17
  def allowed_request_origins=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#18
  def cable; end

  # source://actioncable//lib/action_cable/server/configuration.rb#18
  def cable=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#16
  def connection_class; end

  # source://actioncable//lib/action_cable/server/configuration.rb#16
  def connection_class=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#17
  def disable_request_forgery_protection; end

  # source://actioncable//lib/action_cable/server/configuration.rb#17
  def disable_request_forgery_protection=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#17
  def filter_parameters; end

  # source://actioncable//lib/action_cable/server/configuration.rb#17
  def filter_parameters=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#20
  def health_check_application; end

  # source://actioncable//lib/action_cable/server/configuration.rb#20
  def health_check_application=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#20
  def health_check_path; end

  # source://actioncable//lib/action_cable/server/configuration.rb#20
  def health_check_path=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#15
  def log_tags; end

  # source://actioncable//lib/action_cable/server/configuration.rb#15
  def log_tags=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#15
  def logger; end

  # source://actioncable//lib/action_cable/server/configuration.rb#15
  def logger=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#18
  def mount_path; end

  # source://actioncable//lib/action_cable/server/configuration.rb#18
  def mount_path=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#19
  def precompile_assets; end

  # source://actioncable//lib/action_cable/server/configuration.rb#19
  def precompile_assets=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#40
  def pubsub_adapter; end

  # source://actioncable//lib/action_cable/server/configuration.rb#18
  def url; end

  # source://actioncable//lib/action_cable/server/configuration.rb#18
  def url=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#16
  def worker_pool_size; end

  # source://actioncable//lib/action_cable/server/configuration.rb#16
  def worker_pool_size=(_arg0); end
end

# source://actioncable//lib/action_cable/server/connections.rb#13
module ActionCable::Server::Connections
  # source://actioncable//lib/action_cable/server/connections.rb#20
  def add_connection(connection); end

  # source://actioncable//lib/action_cable/server/connections.rb#16
  def connections; end

  # source://actioncable//lib/action_cable/server/connections.rb#39
  def open_connections_statistics; end

  # source://actioncable//lib/action_cable/server/connections.rb#24
  def remove_connection(connection); end

  # source://actioncable//lib/action_cable/server/connections.rb#33
  def setup_heartbeat_timer; end
end

# source://actioncable//lib/action_cable/server/connections.rb#14
ActionCable::Server::Connections::BEAT_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/server/worker.rb#12
class ActionCable::Server::Worker
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # source://actioncable//lib/action_cable/server/worker.rb#21
  def initialize(max_size: T.unsafe(nil)); end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#912
  def _run_work_callbacks(&block); end

  # source://activesupport/7.2.0/lib/active_support/callbacks.rb#924
  def _work_callbacks; end

  # source://actioncable//lib/action_cable/server/worker.rb#48
  def async_exec(receiver, *args, connection:, &block); end

  # source://actioncable//lib/action_cable/server/worker.rb#52
  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  # source://activesupport/7.2.0/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def connection; end

  # source://activesupport/7.2.0/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def connection=(obj); end

  # source://actioncable//lib/action_cable/server/worker.rb#19
  def executor; end

  # source://actioncable//lib/action_cable/server/worker.rb#32
  def halt; end

  # source://actioncable//lib/action_cable/server/worker.rb#58
  def invoke(receiver, method, *args, connection:, &block); end

  # source://actioncable//lib/action_cable/server/worker.rb#36
  def stopping?; end

  # source://actioncable//lib/action_cable/server/worker.rb#40
  def work(connection, &block); end

  private

  # source://actioncable//lib/action_cable/server/worker.rb#70
  def logger; end

  class << self
    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#916
    def _work_callbacks; end

    # source://activesupport/7.2.0/lib/active_support/callbacks.rb#920
    def _work_callbacks=(value); end

    # source://activesupport/7.2.0/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def connection; end

    # source://activesupport/7.2.0/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def connection=(obj); end
  end
end

# source://actioncable//lib/action_cable/server/worker/active_record_connection_management.rb#8
module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Concern

  # source://actioncable//lib/action_cable/server/worker/active_record_connection_management.rb#17
  def with_database_connections(&block); end
end

# source://actioncable//lib/action_cable/subscription_adapter/async.rb#6
module ActionCable::SubscriptionAdapter; end

# source://actioncable//lib/action_cable/subscription_adapter/async.rb#7
class ActionCable::SubscriptionAdapter::Async < ::ActionCable::SubscriptionAdapter::Inline
  private

  # source://actioncable//lib/action_cable/subscription_adapter/async.rb#9
  def new_subscriber_map; end
end

# source://actioncable//lib/action_cable/subscription_adapter/async.rb#13
class ActionCable::SubscriptionAdapter::Async::AsyncSubscriberMap < ::ActionCable::SubscriptionAdapter::SubscriberMap
  # source://actioncable//lib/action_cable/subscription_adapter/async.rb#14
  def initialize(event_loop); end

  # source://actioncable//lib/action_cable/subscription_adapter/async.rb#19
  def add_subscriber(*_arg0); end

  # source://actioncable//lib/action_cable/subscription_adapter/async.rb#23
  def invoke_callback(*_arg0); end
end

# source://actioncable//lib/action_cable/subscription_adapter/base.rb#7
class ActionCable::SubscriptionAdapter::Base
  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#10
  def initialize(server); end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#15
  def broadcast(channel, payload); end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#31
  def identifier; end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#8
  def logger; end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#8
  def server; end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#27
  def shutdown; end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#19
  def subscribe(channel, message_callback, success_callback = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#23
  def unsubscribe(channel, message_callback); end
end

# source://actioncable//lib/action_cable/subscription_adapter/channel_prefix.rb#7
module ActionCable::SubscriptionAdapter::ChannelPrefix
  # source://actioncable//lib/action_cable/subscription_adapter/channel_prefix.rb#8
  def broadcast(channel, payload); end

  # source://actioncable//lib/action_cable/subscription_adapter/channel_prefix.rb#13
  def subscribe(channel, callback, success_callback = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/subscription_adapter/channel_prefix.rb#18
  def unsubscribe(channel, callback); end

  private

  # source://actioncable//lib/action_cable/subscription_adapter/channel_prefix.rb#25
  def channel_with_prefix(channel); end
end

# source://actioncable//lib/action_cable/subscription_adapter/inline.rb#7
class ActionCable::SubscriptionAdapter::Inline < ::ActionCable::SubscriptionAdapter::Base
  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#8
  def initialize(*_arg0); end

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#13
  def broadcast(channel, payload); end

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#25
  def shutdown; end

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#17
  def subscribe(channel, callback, success_callback = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#21
  def unsubscribe(channel, callback); end

  private

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#34
  def new_subscriber_map; end

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#30
  def subscriber_map; end
end

# source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#7
class ActionCable::SubscriptionAdapter::SubscriberMap
  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#8
  def initialize; end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#49
  def add_channel(channel, on_success); end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#13
  def add_subscriber(channel, subscriber, on_success); end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#38
  def broadcast(channel, message); end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#56
  def invoke_callback(callback, message); end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#53
  def remove_channel(channel); end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#27
  def remove_subscriber(channel, subscriber); end
end

# source://actioncable//lib/action_cable/subscription_adapter/test.rb#17
class ActionCable::SubscriptionAdapter::Test < ::ActionCable::SubscriptionAdapter::Async
  # source://actioncable//lib/action_cable/subscription_adapter/test.rb#18
  def broadcast(channel, payload); end

  # source://actioncable//lib/action_cable/subscription_adapter/test.rb#23
  def broadcasts(channel); end

  # source://actioncable//lib/action_cable/subscription_adapter/test.rb#31
  def clear; end

  # source://actioncable//lib/action_cable/subscription_adapter/test.rb#27
  def clear_messages(channel); end

  private

  # source://actioncable//lib/action_cable/subscription_adapter/test.rb#36
  def channels_data; end
end

# source://actioncable//lib/action_cable/test_case.rb#8
class ActionCable::TestCase < ::ActiveSupport::TestCase
  include ::ActionCable::TestHelper
end

# source://actioncable//lib/action_cable/test_helper.rb#7
module ActionCable::TestHelper
  # source://actioncable//lib/action_cable/test_helper.rb#18
  def after_teardown; end

  # source://actioncable//lib/action_cable/test_helper.rb#116
  def assert_broadcast_on(stream, data, &block); end

  # source://actioncable//lib/action_cable/test_helper.rb#48
  def assert_broadcasts(stream, number, &block); end

  # source://actioncable//lib/action_cable/test_helper.rb#80
  def assert_no_broadcasts(stream, &block); end

  # source://actioncable//lib/action_cable/test_helper.rb#8
  def before_setup; end

  # source://actioncable//lib/action_cable/test_helper.rb#146
  def broadcasts(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/test_helper.rb#96
  def capture_broadcasts(stream, &block); end

  # source://actioncable//lib/action_cable/test_helper.rb#146
  def clear_messages(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/test_helper.rb#142
  def pubsub_adapter; end

  private

  # source://actioncable//lib/action_cable/test_helper.rb#149
  def new_broadcasts_from(current_messages, stream, assertion, &block); end
end

# source://actioncable//lib/action_cable/gem_version.rb#11
module ActionCable::VERSION; end

# source://actioncable//lib/action_cable/gem_version.rb#12
ActionCable::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/gem_version.rb#13
ActionCable::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/gem_version.rb#15
ActionCable::VERSION::PRE = T.let(T.unsafe(nil), T.untyped)

# source://actioncable//lib/action_cable/gem_version.rb#17
ActionCable::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://actioncable//lib/action_cable/gem_version.rb#14
ActionCable::VERSION::TINY = T.let(T.unsafe(nil), Integer)
