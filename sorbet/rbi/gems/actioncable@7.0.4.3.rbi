# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `actioncable` gem.
# Please instead update this file by running `bin/tapioca gem actioncable`.

# source://actioncable//lib/action_cable/gem_version.rb#3
module ActionCable
  extend ::ActiveSupport::Autoload

  private

  # source://actioncable//lib/action_cable.rb#51
  def server; end

  class << self
    # source://actioncable//lib/action_cable/gem_version.rb#5
    def gem_version; end

    # source://actioncable//lib/action_cable.rb#51
    def server; end

    # source://actioncable//lib/action_cable/version.rb#7
    def version; end
  end
end

# source://actioncable//lib/action_cable/channel.rb#4
module ActionCable::Channel
  extend ::ActiveSupport::Autoload
end

# source://actioncable//lib/action_cable/channel/base.rb#97
class ActionCable::Channel::Base
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Channel::Callbacks
  include ::ActionCable::Channel::PeriodicTimers
  include ::ActionCable::Channel::Streams
  include ::ActionCable::Channel::Naming
  include ::ActionCable::Channel::Broadcasting
  include ::ActiveSupport::Rescuable
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Channel::Callbacks::ClassMethods
  extend ::ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::ActionCable::Channel::Naming::ClassMethods
  extend ::ActionCable::Channel::Broadcasting::ClassMethods
  extend ::ActiveSupport::Rescuable::ClassMethods

  # source://actioncable//lib/action_cable/channel/base.rb#144
  def initialize(connection, identifier, params = T.unsafe(nil)); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
  def __callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
  def __callbacks?; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_subscribe_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_unsubscribe_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _subscribe_callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _unsubscribe_callbacks; end

  # source://actioncable//lib/action_cable/channel/base.rb#105
  def connection; end

  # source://actioncable//lib/action_cable/channel/base.rb#105
  def identifier; end

  # source://actioncable//lib/action_cable/channel/base.rb#106
  def logger(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/channel/base.rb#105
  def params; end

  # source://actioncable//lib/action_cable/channel/base.rb#164
  def perform_action(data); end

  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#9
  def periodic_timers=(_arg0); end

  # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
  def rescue_handlers; end

  # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
  def rescue_handlers=(_arg0); end

  # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
  def rescue_handlers?; end

  # source://actioncable//lib/action_cable/channel/base.rb#179
  def subscribe_to_channel; end

  # source://actioncable//lib/action_cable/channel/base.rb#190
  def unsubscribe_from_channel; end

  private

  # source://actioncable//lib/action_cable/channel/base.rb#276
  def action_signature(action, data); end

  # source://actioncable//lib/action_cable/channel/base.rb#228
  def defer_subscription_confirmation!; end

  # source://actioncable//lib/action_cable/channel/base.rb#232
  def defer_subscription_confirmation?; end

  # source://actioncable//lib/action_cable/channel/base.rb#248
  def delegate_connection_identifiers; end

  # source://actioncable//lib/action_cable/channel/base.rb#264
  def dispatch_action(action, data); end

  # source://actioncable//lib/action_cable/channel/base.rb#222
  def ensure_confirmation_sent; end

  # source://actioncable//lib/action_cable/channel/base.rb#256
  def extract_action(data); end

  # source://actioncable//lib/action_cable/channel/base.rb#260
  def processable_action?(action); end

  # source://actioncable//lib/action_cable/channel/base.rb#240
  def reject; end

  # source://actioncable//lib/action_cable/channel/base.rb#295
  def reject_subscription; end

  # source://actioncable//lib/action_cable/channel/base.rb#199
  def subscribed; end

  # source://actioncable//lib/action_cable/channel/base.rb#236
  def subscription_confirmation_sent?; end

  # source://actioncable//lib/action_cable/channel/base.rb#244
  def subscription_rejected?; end

  # source://actioncable//lib/action_cable/channel/base.rb#211
  def transmit(data, via: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/base.rb#284
  def transmit_subscription_confirmation; end

  # source://actioncable//lib/action_cable/channel/base.rb#300
  def transmit_subscription_rejection; end

  # source://actioncable//lib/action_cable/channel/base.rb#205
  def unsubscribed; end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks?; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _subscribe_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _subscribe_callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _unsubscribe_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _unsubscribe_callbacks=(value); end

    # source://actioncable//lib/action_cable/channel/base.rb#117
    def action_methods; end

    # source://actioncable//lib/action_cable/channel/periodic_timers.rb#9
    def periodic_timers; end

    # source://actioncable//lib/action_cable/channel/periodic_timers.rb#9
    def periodic_timers=(value); end

    # source://actioncable//lib/action_cable/channel/periodic_timers.rb#9
    def periodic_timers?; end

    # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
    def rescue_handlers; end

    # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
    def rescue_handlers=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
    def rescue_handlers?; end

    private

    # source://actioncable//lib/action_cable/channel/base.rb#133
    def clear_action_methods!; end

    # source://actioncable//lib/action_cable/channel/base.rb#138
    def method_added(name); end
  end
end

# source://actioncable//lib/action_cable/channel/broadcasting.rb#7
module ActionCable::Channel::Broadcasting
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionCable::Channel::Broadcasting::ClassMethods

  # source://actioncable//lib/action_cable/channel/broadcasting.rb#10
  def broadcast_to(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/channel/broadcasting.rb#10
  def broadcasting_for(*_arg0, **_arg1, &_arg2); end
end

# source://actioncable//lib/action_cable/channel/broadcasting.rb#12
module ActionCable::Channel::Broadcasting::ClassMethods
  # source://actioncable//lib/action_cable/channel/broadcasting.rb#14
  def broadcast_to(model, message); end

  # source://actioncable//lib/action_cable/channel/broadcasting.rb#24
  def broadcasting_for(model); end

  # source://actioncable//lib/action_cable/channel/broadcasting.rb#28
  def serialize_broadcasting(object); end
end

# source://actioncable//lib/action_cable/channel/callbacks.rb#7
module ActionCable::Channel::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActionCable::Channel::Callbacks::ClassMethods

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

# source://actioncable//lib/action_cable/channel/callbacks.rb#16
module ActionCable::Channel::Callbacks::ClassMethods
  # source://actioncable//lib/action_cable/channel/callbacks.rb#21
  def after_subscribe(*methods, &block); end

  # source://actioncable//lib/action_cable/channel/callbacks.rb#30
  def after_unsubscribe(*methods, &block); end

  # source://actioncable//lib/action_cable/channel/callbacks.rb#17
  def before_subscribe(*methods, &block); end

  # source://actioncable//lib/action_cable/channel/callbacks.rb#26
  def before_unsubscribe(*methods, &block); end

  # source://actioncable//lib/action_cable/channel/callbacks.rb#21
  def on_subscribe(*methods, &block); end

  # source://actioncable//lib/action_cable/channel/callbacks.rb#30
  def on_unsubscribe(*methods, &block); end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#21
module ActionCable::Channel::ChannelStub
  # source://actioncable//lib/action_cable/channel/test_case.rb#22
  def confirmed?; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#26
  def rejected?; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#43
  def start_periodic_timers; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#34
  def stop_all_streams; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#43
  def stop_periodic_timers; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#30
  def stream_from(broadcasting, *_arg1); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#38
  def streams; end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#47
class ActionCable::Channel::ConnectionStub
  # source://actioncable//lib/action_cable/channel/test_case.rb#50
  def initialize(identifiers = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#66
  def connection_identifier; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#48
  def identifiers; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#48
  def logger; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#48
  def subscriptions; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#48
  def transmissions; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#62
  def transmit(cable_message); end

  private

  # source://actioncable//lib/action_cable/channel/test_case.rb#71
  def connection_gid(ids); end
end

# source://actioncable//lib/action_cable/channel/naming.rb#5
module ActionCable::Channel::Naming
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionCable::Channel::Naming::ClassMethods

  # source://actioncable//lib/action_cable/channel/naming.rb#22
  def channel_name(*_arg0, **_arg1, &_arg2); end
end

# source://actioncable//lib/action_cable/channel/naming.rb#8
module ActionCable::Channel::Naming::ClassMethods
  # source://actioncable//lib/action_cable/channel/naming.rb#16
  def channel_name; end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#10
class ActionCable::Channel::NonInferrableChannelError < ::StandardError
  # source://actioncable//lib/action_cable/channel/test_case.rb#11
  def initialize(name); end
end

# source://actioncable//lib/action_cable/channel/periodic_timers.rb#5
module ActionCable::Channel::PeriodicTimers
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionCable::Channel::PeriodicTimers::ClassMethods

  private

  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#56
  def active_periodic_timers; end

  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#66
  def start_periodic_timer(callback, every:); end

  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#60
  def start_periodic_timers; end

  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#72
  def stop_periodic_timers; end

  module GeneratedClassMethods
    def periodic_timers; end
    def periodic_timers=(value); end
    def periodic_timers?; end
  end

  module GeneratedInstanceMethods
    def periodic_timers=(value); end
  end
end

# source://actioncable//lib/action_cable/channel/periodic_timers.rb#15
module ActionCable::Channel::PeriodicTimers::ClassMethods
  # source://actioncable//lib/action_cable/channel/periodic_timers.rb#31
  def periodically(callback_or_method_name = T.unsafe(nil), every:, &block); end
end

# source://actioncable//lib/action_cable/channel/streams.rb#65
module ActionCable::Channel::Streams
  extend ::ActiveSupport::Concern

  # source://actioncable//lib/action_cable/channel/streams.rb#138
  def pubsub(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/channel/streams.rb#120
  def stop_all_streams; end

  # source://actioncable//lib/action_cable/channel/streams.rb#115
  def stop_stream_for(model); end

  # source://actioncable//lib/action_cable/channel/streams.rb#106
  def stop_stream_from(broadcasting); end

  # source://actioncable//lib/action_cable/channel/streams.rb#101
  def stream_for(model, callback = T.unsafe(nil), coder: T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/channel/streams.rb#76
  def stream_from(broadcasting, callback = T.unsafe(nil), coder: T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/channel/streams.rb#129
  def stream_or_reject_for(model); end

  private

  # source://actioncable//lib/action_cable/channel/streams.rb#174
  def default_stream_handler(broadcasting, coder:); end

  # source://actioncable//lib/action_cable/channel/streams.rb#195
  def identity_handler; end

  # source://actioncable//lib/action_cable/channel/streams.rb#179
  def stream_decoder(handler = T.unsafe(nil), coder:); end

  # source://actioncable//lib/action_cable/channel/streams.rb#158
  def stream_handler(broadcasting, user_handler, coder: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/streams.rb#187
  def stream_transmitter(handler = T.unsafe(nil), broadcasting:); end

  # source://actioncable//lib/action_cable/channel/streams.rb#140
  def streams; end

  # source://actioncable//lib/action_cable/channel/streams.rb#146
  def worker_pool_stream_handler(broadcasting, user_handler, coder: T.unsafe(nil)); end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#181
class ActionCable::Channel::TestCase < ::ActiveSupport::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::TestHelper
  include ::ActionCable::Channel::TestCase::Behavior
  extend ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  extend ::ActionCable::Channel::TestCase::Behavior::ClassMethods

  # source://actioncable//lib/action_cable/channel/test_case.rb#191
  def _channel_class; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#191
  def _channel_class=(_arg0); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#191
  def _channel_class?; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#193
  def connection; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#193
  def subscription; end

  class << self
    # source://actioncable//lib/action_cable/channel/test_case.rb#191
    def _channel_class; end

    # source://actioncable//lib/action_cable/channel/test_case.rb#191
    def _channel_class=(value); end

    # source://actioncable//lib/action_cable/channel/test_case.rb#191
    def _channel_class?; end
  end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#182
module ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Testing::ConstantLookup

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionCable::Channel::TestCase::Behavior::ClassMethods

  # source://actioncable//lib/action_cable/channel/test_case.rb#273
  def assert_broadcast_on(stream_or_object, *args); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#269
  def assert_broadcasts(stream_or_object, *args); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#295
  def assert_has_stream(stream); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#306
  def assert_has_stream_for(object); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#284
  def assert_no_streams; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#256
  def perform(action, data = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#234
  def stub_connection(identifiers = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#239
  def subscribe(params = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#262
  def transmissions; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#248
  def unsubscribe; end

  private

  # source://actioncable//lib/action_cable/channel/test_case.rb#315
  def broadcasting_for(stream_or_object); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#311
  def check_subscribed!; end

  module GeneratedClassMethods
    def _channel_class; end
    def _channel_class=(value); end
    def _channel_class?; end
  end

  module GeneratedInstanceMethods
    def _channel_class; end
    def _channel_class=(value); end
    def _channel_class?; end
  end
end

# source://actioncable//lib/action_cable/channel/test_case.rb#188
ActionCable::Channel::TestCase::Behavior::CHANNEL_IDENTIFIER = T.let(T.unsafe(nil), String)

# source://actioncable//lib/action_cable/channel/test_case.rb#198
module ActionCable::Channel::TestCase::Behavior::ClassMethods
  # source://actioncable//lib/action_cable/channel/test_case.rb#210
  def channel_class; end

  # source://actioncable//lib/action_cable/channel/test_case.rb#218
  def determine_default_channel(name); end

  # source://actioncable//lib/action_cable/channel/test_case.rb#199
  def tests(channel); end
end

# source://actioncable//lib/action_cable/connection.rb#4
module ActionCable::Connection
  extend ::ActiveSupport::Autoload
end

# source://actioncable//lib/action_cable/connection/test_case.rb#20
module ActionCable::Connection::Assertions
  # source://actioncable//lib/action_cable/connection/test_case.rb#25
  def assert_reject_connection(&block); end
end

# source://actioncable//lib/action_cable/connection/authorization.rb#5
module ActionCable::Connection::Authorization
  # source://actioncable//lib/action_cable/connection/authorization.rb#9
  def reject_unauthorized_connection; end
end

# source://actioncable//lib/action_cable/connection/authorization.rb#6
class ActionCable::Connection::Authorization::UnauthorizedError < ::StandardError; end

# source://actioncable//lib/action_cable/connection/base.rb#46
class ActionCable::Connection::Base
  include ::ActionCable::Connection::Identification
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Authorization
  include ::ActiveSupport::Rescuable
  extend ::ActionCable::Connection::Identification::ClassMethods
  extend ::ActiveSupport::Rescuable::ClassMethods

  # source://actioncable//lib/action_cable/connection/base.rb#55
  def initialize(server, env, coder: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/connection/base.rb#125
  def beat; end

  # source://actioncable//lib/action_cable/connection/base.rb#100
  def close(reason: T.unsafe(nil), reconnect: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/connection/base.rb#87
  def dispatch_websocket_message(websocket_message); end

  # source://actioncable//lib/action_cable/connection/base.rb#52
  def env; end

  # source://actioncable//lib/action_cable/connection/base.rb#53
  def event_loop(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/connection/identification.rb#11
  def identifiers; end

  # source://actioncable//lib/action_cable/connection/identification.rb#11
  def identifiers=(_arg0); end

  # source://actioncable//lib/action_cable/connection/identification.rb#11
  def identifiers?; end

  # source://actioncable//lib/action_cable/connection/base.rb#52
  def logger; end

  # source://actioncable//lib/action_cable/connection/base.rb#142
  def on_close(reason, code); end

  # source://actioncable//lib/action_cable/connection/base.rb#137
  def on_error(message); end

  # source://actioncable//lib/action_cable/connection/base.rb#133
  def on_message(message); end

  # source://actioncable//lib/action_cable/connection/base.rb#129
  def on_open; end

  # source://actioncable//lib/action_cable/connection/base.rb#71
  def process; end

  # source://actioncable//lib/action_cable/connection/base.rb#52
  def protocol; end

  # source://actioncable//lib/action_cable/connection/base.rb#53
  def pubsub(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/connection/base.rb#83
  def receive(websocket_message); end

  # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
  def rescue_handlers; end

  # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
  def rescue_handlers=(_arg0); end

  # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
  def rescue_handlers?; end

  # source://actioncable//lib/action_cable/connection/base.rb#110
  def send_async(method, *arguments); end

  # source://actioncable//lib/action_cable/connection/base.rb#52
  def server; end

  # source://actioncable//lib/action_cable/connection/base.rb#116
  def statistics; end

  # source://actioncable//lib/action_cable/connection/base.rb#52
  def subscriptions; end

  # source://actioncable//lib/action_cable/connection/base.rb#95
  def transmit(cable_message); end

  # source://actioncable//lib/action_cable/connection/base.rb#52
  def worker_pool; end

  private

  # source://actioncable//lib/action_cable/connection/base.rb#201
  def allow_request_origin?; end

  # source://actioncable//lib/action_cable/connection/base.rb#159
  def cookies; end

  # source://actioncable//lib/action_cable/connection/base.rb#167
  def decode(websocket_message); end

  # source://actioncable//lib/action_cable/connection/base.rb#163
  def encode(cable_message); end

  # source://actioncable//lib/action_cable/connection/base.rb#243
  def finished_request_message; end

  # source://actioncable//lib/action_cable/connection/base.rb#183
  def handle_close; end

  # source://actioncable//lib/action_cable/connection/base.rb#171
  def handle_open; end

  # source://actioncable//lib/action_cable/connection/base.rb#251
  def invalid_request_message; end

  # source://actioncable//lib/action_cable/connection/base.rb#148
  def message_buffer; end

  # source://actioncable//lib/action_cable/connection/base.rb#229
  def new_tagged_logger; end

  # source://actioncable//lib/action_cable/connection/base.rb#151
  def request; end

  # source://actioncable//lib/action_cable/connection/base.rb#220
  def respond_to_invalid_request; end

  # source://actioncable//lib/action_cable/connection/base.rb#215
  def respond_to_successful_request; end

  # source://actioncable//lib/action_cable/connection/base.rb#194
  def send_welcome_message; end

  # source://actioncable//lib/action_cable/connection/base.rb#234
  def started_request_message; end

  # source://actioncable//lib/action_cable/connection/base.rb#257
  def successful_request_message; end

  # source://actioncable//lib/action_cable/connection/base.rb#147
  def websocket; end

  class << self
    # source://actioncable//lib/action_cable/connection/identification.rb#11
    def identifiers; end

    # source://actioncable//lib/action_cable/connection/identification.rb#11
    def identifiers=(value); end

    # source://actioncable//lib/action_cable/connection/identification.rb#11
    def identifiers?; end

    # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
    def rescue_handlers; end

    # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
    def rescue_handlers=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
    def rescue_handlers?; end
  end
end

# source://actioncable//lib/action_cable/connection/client_socket.rb#11
class ActionCable::Connection::ClientSocket
  # source://actioncable//lib/action_cable/connection/client_socket.rb#34
  def initialize(env, event_target, event_loop, protocols); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#112
  def alive?; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#108
  def client_gone; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#90
  def close(code = T.unsafe(nil), reason = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#32
  def env; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#104
  def parse(data); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#116
  def protocol; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#69
  def rack_response; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#57
  def start_driver; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#80
  def transmit(message); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#32
  def url; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#74
  def write(data); end

  private

  # source://actioncable//lib/action_cable/connection/client_socket.rb#140
  def begin_close(reason, code); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#134
  def emit_error(message); end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#149
  def finalize_close; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#121
  def open; end

  # source://actioncable//lib/action_cable/connection/client_socket.rb#128
  def receive_message(data); end

  class << self
    # source://actioncable//lib/action_cable/connection/client_socket.rb#12
    def determine_url(env); end

    # source://actioncable//lib/action_cable/connection/client_socket.rb#17
    def secure_request?(env); end
  end
end

# source://actioncable//lib/action_cable/connection/client_socket.rb#30
ActionCable::Connection::ClientSocket::CLOSED = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/connection/client_socket.rb#29
ActionCable::Connection::ClientSocket::CLOSING = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/connection/client_socket.rb#27
ActionCable::Connection::ClientSocket::CONNECTING = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/connection/client_socket.rb#28
ActionCable::Connection::ClientSocket::OPEN = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/connection/identification.rb#7
module ActionCable::Connection::Identification
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionCable::Connection::Identification::ClassMethods

  # source://actioncable//lib/action_cable/connection/identification.rb#27
  def connection_identifier; end

  private

  # source://actioncable//lib/action_cable/connection/identification.rb#36
  def connection_gid(ids); end

  module GeneratedClassMethods
    def identifiers; end
    def identifiers=(value); end
    def identifiers?; end
  end

  module GeneratedInstanceMethods
    def identifiers; end
    def identifiers=(value); end
    def identifiers?; end
  end
end

# source://actioncable//lib/action_cable/connection/identification.rb#14
module ActionCable::Connection::Identification::ClassMethods
  # source://actioncable//lib/action_cable/connection/identification.rb#20
  def identified_by(*identifiers); end
end

# source://actioncable//lib/action_cable/connection/internal_channel.rb#6
module ActionCable::Connection::InternalChannel
  extend ::ActiveSupport::Concern

  private

  # source://actioncable//lib/action_cable/connection/internal_channel.rb#10
  def internal_channel; end

  # source://actioncable//lib/action_cable/connection/internal_channel.rb#31
  def process_internal_message(message); end

  # source://actioncable//lib/action_cable/connection/internal_channel.rb#14
  def subscribe_to_internal_channel; end

  # source://actioncable//lib/action_cable/connection/internal_channel.rb#25
  def unsubscribe_from_internal_channel; end
end

# source://actioncable//lib/action_cable/connection/message_buffer.rb#6
class ActionCable::Connection::MessageBuffer
  # source://actioncable//lib/action_cable/connection/message_buffer.rb#7
  def initialize(connection); end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#12
  def append(message); end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#28
  def process!; end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#24
  def processing?; end

  private

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#45
  def buffer(message); end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#35
  def buffered_messages; end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#34
  def connection; end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#41
  def receive(message); end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#49
  def receive_buffered_messages; end

  # source://actioncable//lib/action_cable/connection/message_buffer.rb#37
  def valid?(message); end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#12
class ActionCable::Connection::NonInferrableConnectionError < ::StandardError
  # source://actioncable//lib/action_cable/connection/test_case.rb#13
  def initialize(name); end
end

# source://actioncable//lib/action_cable/connection/stream.rb#11
class ActionCable::Connection::Stream
  # source://actioncable//lib/action_cable/connection/stream.rb#12
  def initialize(event_loop, socket); end

  # source://actioncable//lib/action_cable/connection/stream.rb#28
  def close; end

  # source://actioncable//lib/action_cable/connection/stream.rb#24
  def each(&callback); end

  # source://actioncable//lib/action_cable/connection/stream.rb#72
  def flush_write_buffer; end

  # source://actioncable//lib/action_cable/connection/stream.rb#98
  def hijack_rack_socket; end

  # source://actioncable//lib/action_cable/connection/stream.rb#94
  def receive(data); end

  # source://actioncable//lib/action_cable/connection/stream.rb#33
  def shutdown; end

  # source://actioncable//lib/action_cable/connection/stream.rb#37
  def write(data); end

  private

  # source://actioncable//lib/action_cable/connection/stream.rb#110
  def clean_rack_hijack; end
end

# source://actioncable//lib/action_cable/connection/stream_event_loop.rb#8
class ActionCable::Connection::StreamEventLoop
  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#9
  def initialize; end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#29
  def attach(io, stream); end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#37
  def detach(io, stream); end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#22
  def post(task = T.unsafe(nil), &block); end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#55
  def stop; end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#18
  def timer(interval, &block); end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#46
  def writes_pending(io); end

  private

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#85
  def run; end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#61
  def spawn; end

  # source://actioncable//lib/action_cable/connection/stream_event_loop.rb#81
  def wakeup; end
end

# source://actioncable//lib/action_cable/connection/subscriptions.rb#9
class ActionCable::Connection::Subscriptions
  # source://actioncable//lib/action_cable/connection/subscriptions.rb#10
  def initialize(connection); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#28
  def add(data); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#15
  def execute_command(data); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#59
  def identifiers; end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#69
  def logger(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#55
  def perform_action(data); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#45
  def remove(data); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#50
  def remove_subscription(subscription); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#63
  def unsubscribe_from_all; end

  private

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#68
  def connection; end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#71
  def find(data); end

  # source://actioncable//lib/action_cable/connection/subscriptions.rb#68
  def subscriptions; end
end

# source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#8
class ActionCable::Connection::TaggedLoggerProxy
  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#11
  def initialize(logger, tags:); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#16
  def add_tags(*tags); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#31
  def debug(message); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#31
  def error(message); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#31
  def fatal(message); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#31
  def info(message); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#21
  def tag(logger, &block); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#9
  def tags; end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#31
  def unknown(message); end

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#31
  def warn(message); end

  private

  # source://actioncable//lib/action_cable/connection/tagged_logger_proxy.rb#37
  def log(type, message); end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#129
class ActionCable::Connection::TestCase < ::ActiveSupport::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Connection::Assertions
  include ::ActionCable::Connection::TestCase::Behavior
  extend ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  extend ::ActionCable::Connection::TestCase::Behavior::ClassMethods

  # source://actioncable//lib/action_cable/connection/test_case.rb#139
  def _connection_class; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#139
  def _connection_class=(_arg0); end

  # source://actioncable//lib/action_cable/connection/test_case.rb#139
  def _connection_class?; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#141
  def connection; end

  class << self
    # source://actioncable//lib/action_cable/connection/test_case.rb#139
    def _connection_class; end

    # source://actioncable//lib/action_cable/connection/test_case.rb#139
    def _connection_class=(value); end

    # source://actioncable//lib/action_cable/connection/test_case.rb#139
    def _connection_class?; end
  end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#130
module ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Testing::ConstantLookup

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionCable::Connection::TestCase::Behavior::ClassMethods

  # source://actioncable//lib/action_cable/connection/test_case.rb#183
  def connect(path = T.unsafe(nil), **request_params); end

  # source://actioncable//lib/action_cable/connection/test_case.rb#203
  def cookies; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#196
  def disconnect; end

  private

  # source://actioncable//lib/action_cable/connection/test_case.rb#208
  def build_test_request(path, params: T.unsafe(nil), headers: T.unsafe(nil), session: T.unsafe(nil), env: T.unsafe(nil)); end

  module GeneratedClassMethods
    def _connection_class; end
    def _connection_class=(value); end
    def _connection_class?; end
  end

  module GeneratedInstanceMethods
    def _connection_class; end
    def _connection_class=(value); end
    def _connection_class?; end
  end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#146
module ActionCable::Connection::TestCase::Behavior::ClassMethods
  # source://actioncable//lib/action_cable/connection/test_case.rb#158
  def connection_class; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#166
  def determine_default_connection(name); end

  # source://actioncable//lib/action_cable/connection/test_case.rb#147
  def tests(connection); end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#133
ActionCable::Connection::TestCase::Behavior::DEFAULT_PATH = T.let(T.unsafe(nil), String)

# source://actioncable//lib/action_cable/connection/test_case.rb#47
module ActionCable::Connection::TestConnection
  # source://actioncable//lib/action_cable/connection/test_case.rb#50
  def initialize(request); end

  # source://actioncable//lib/action_cable/connection/test_case.rb#48
  def logger; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#48
  def request; end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#33
class ActionCable::Connection::TestCookieJar < ::ActiveSupport::HashWithIndifferentAccess
  # source://actioncable//lib/action_cable/connection/test_case.rb#38
  def encrypted; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#34
  def signed; end
end

# source://actioncable//lib/action_cable/connection/test_case.rb#43
class ActionCable::Connection::TestRequest < ::ActionDispatch::TestRequest
  # source://actioncable//lib/action_cable/connection/test_case.rb#44
  def cookie_jar; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#44
  def cookie_jar=(_arg0); end

  # source://actioncable//lib/action_cable/connection/test_case.rb#44
  def session; end

  # source://actioncable//lib/action_cable/connection/test_case.rb#44
  def session=(_arg0); end
end

# source://actioncable//lib/action_cable/connection/web_socket.rb#8
class ActionCable::Connection::WebSocket
  # source://actioncable//lib/action_cable/connection/web_socket.rb#9
  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#17
  def alive?; end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#25
  def close; end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#13
  def possible?; end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#29
  def protocol; end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#33
  def rack_response; end

  # source://actioncable//lib/action_cable/connection/web_socket.rb#21
  def transmit(data); end

  private

  # source://actioncable//lib/action_cable/connection/web_socket.rb#38
  def websocket; end
end

# source://actioncable//lib/action_cable/engine.rb#9
class ActionCable::Engine < ::Rails::Engine
  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end
  end
end

# source://actioncable//lib/action_cable/helpers/action_cable_helper.rb#4
module ActionCable::Helpers; end

# source://actioncable//lib/action_cable/helpers/action_cable_helper.rb#5
module ActionCable::Helpers::ActionCableHelper
  # source://actioncable//lib/action_cable/helpers/action_cable_helper.rb#34
  def action_cable_meta_tag; end
end

# source://actioncable//lib/action_cable.rb#33
ActionCable::INTERNAL = T.let(T.unsafe(nil), Hash)

# source://actioncable//lib/action_cable/remote_connections.rb#22
class ActionCable::RemoteConnections
  # source://actioncable//lib/action_cable/remote_connections.rb#25
  def initialize(server); end

  # source://actioncable//lib/action_cable/remote_connections.rb#23
  def server; end

  # source://actioncable//lib/action_cable/remote_connections.rb#29
  def where(identifier); end
end

# source://actioncable//lib/action_cable/remote_connections.rb#36
class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Identification
  extend ::ActionCable::Connection::Identification::ClassMethods

  # source://actioncable//lib/action_cable/remote_connections.rb#41
  def initialize(server, ids); end

  # source://actioncable//lib/action_cable/remote_connections.rb#47
  def disconnect; end

  # source://actioncable//lib/action_cable/remote_connections.rb#52
  def identifiers; end

  # source://actioncable//lib/action_cable/connection/identification.rb#11
  def identifiers=(_arg0); end

  # source://actioncable//lib/action_cable/connection/identification.rb#11
  def identifiers?; end

  protected

  # source://actioncable//lib/action_cable/remote_connections.rb#57
  def server; end

  private

  # source://actioncable//lib/action_cable/remote_connections.rb#60
  def set_identifier_instance_vars(ids); end

  # source://actioncable//lib/action_cable/remote_connections.rb#65
  def valid_identifiers?(ids); end

  class << self
    # source://actioncable//lib/action_cable/connection/identification.rb#11
    def identifiers; end

    # source://actioncable//lib/action_cable/connection/identification.rb#11
    def identifiers=(value); end

    # source://actioncable//lib/action_cable/connection/identification.rb#11
    def identifiers?; end
  end
end

# source://actioncable//lib/action_cable/remote_connections.rb#37
class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError < ::StandardError; end

# source://actioncable//lib/action_cable/server.rb#4
module ActionCable::Server
  extend ::ActiveSupport::Autoload
end

# source://actioncable//lib/action_cable/server/base.rb#11
class ActionCable::Server::Base
  include ::ActionCable::Server::Broadcasting
  include ::ActionCable::Server::Connections

  # source://actioncable//lib/action_cable/server/base.rb#24
  def initialize(config: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/server/base.rb#31
  def call(env); end

  # source://actioncable//lib/action_cable/server/base.rb#17
  def config; end

  # source://actioncable//lib/action_cable/server/base.rb#87
  def connection_identifiers; end

  # source://actioncable//lib/action_cable/server/base.rb#37
  def disconnect(identifiers); end

  # source://actioncable//lib/action_cable/server/base.rb#62
  def event_loop; end

  # source://actioncable//lib/action_cable/server/base.rb#20
  def logger(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/server/base.rb#22
  def mutex; end

  # source://actioncable//lib/action_cable/server/base.rb#82
  def pubsub; end

  # source://actioncable//lib/action_cable/server/base.rb#58
  def remote_connections; end

  # source://actioncable//lib/action_cable/server/base.rb#41
  def restart; end

  # source://actioncable//lib/action_cable/server/base.rb#77
  def worker_pool; end

  class << self
    # source://actioncable//lib/action_cable/server/base.rb#15
    def config; end

    # source://actioncable//lib/action_cable/server/base.rb#15
    def config=(val); end

    # source://actioncable//lib/action_cable/server/base.rb#19
    def logger; end
  end
end

# source://actioncable//lib/action_cable/server/broadcasting.rb#22
module ActionCable::Server::Broadcasting
  # source://actioncable//lib/action_cable/server/broadcasting.rb#24
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/server/broadcasting.rb#30
  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

# source://actioncable//lib/action_cable/server/broadcasting.rb#35
class ActionCable::Server::Broadcasting::Broadcaster
  # source://actioncable//lib/action_cable/server/broadcasting.rb#38
  def initialize(server, broadcasting, coder:); end

  # source://actioncable//lib/action_cable/server/broadcasting.rb#42
  def broadcast(message); end

  # source://actioncable//lib/action_cable/server/broadcasting.rb#36
  def broadcasting; end

  # source://actioncable//lib/action_cable/server/broadcasting.rb#36
  def coder; end

  # source://actioncable//lib/action_cable/server/broadcasting.rb#36
  def server; end
end

# source://actioncable//lib/action_cable/server/configuration.rb#7
class ActionCable::Server::Configuration
  # source://actioncable//lib/action_cable/server/configuration.rb#14
  def initialize; end

  # source://actioncable//lib/action_cable/server/configuration.rb#10
  def allow_same_origin_as_host; end

  # source://actioncable//lib/action_cable/server/configuration.rb#10
  def allow_same_origin_as_host=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#10
  def allowed_request_origins; end

  # source://actioncable//lib/action_cable/server/configuration.rb#10
  def allowed_request_origins=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#11
  def cable; end

  # source://actioncable//lib/action_cable/server/configuration.rb#11
  def cable=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#9
  def connection_class; end

  # source://actioncable//lib/action_cable/server/configuration.rb#9
  def connection_class=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#10
  def disable_request_forgery_protection; end

  # source://actioncable//lib/action_cable/server/configuration.rb#10
  def disable_request_forgery_protection=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#8
  def log_tags; end

  # source://actioncable//lib/action_cable/server/configuration.rb#8
  def log_tags=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#8
  def logger; end

  # source://actioncable//lib/action_cable/server/configuration.rb#8
  def logger=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#11
  def mount_path; end

  # source://actioncable//lib/action_cable/server/configuration.rb#11
  def mount_path=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#12
  def precompile_assets; end

  # source://actioncable//lib/action_cable/server/configuration.rb#12
  def precompile_assets=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#27
  def pubsub_adapter; end

  # source://actioncable//lib/action_cable/server/configuration.rb#11
  def url; end

  # source://actioncable//lib/action_cable/server/configuration.rb#11
  def url=(_arg0); end

  # source://actioncable//lib/action_cable/server/configuration.rb#9
  def worker_pool_size; end

  # source://actioncable//lib/action_cable/server/configuration.rb#9
  def worker_pool_size=(_arg0); end
end

# source://actioncable//lib/action_cable/server/connections.rb#7
module ActionCable::Server::Connections
  # source://actioncable//lib/action_cable/server/connections.rb#14
  def add_connection(connection); end

  # source://actioncable//lib/action_cable/server/connections.rb#10
  def connections; end

  # source://actioncable//lib/action_cable/server/connections.rb#31
  def open_connections_statistics; end

  # source://actioncable//lib/action_cable/server/connections.rb#18
  def remove_connection(connection); end

  # source://actioncable//lib/action_cable/server/connections.rb#25
  def setup_heartbeat_timer; end
end

# source://actioncable//lib/action_cable/server/connections.rb#8
ActionCable::Server::Connections::BEAT_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/server/worker/active_record_connection_management.rb#5
class ActionCable::Server::Worker
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # source://actioncable//lib/action_cable/server/worker.rb#20
  def initialize(max_size: T.unsafe(nil)); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
  def __callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
  def __callbacks?; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_work_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _work_callbacks; end

  # source://actioncable//lib/action_cable/server/worker.rb#47
  def async_exec(receiver, *args, connection:, &block); end

  # source://actioncable//lib/action_cable/server/worker.rb#51
  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def connection; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def connection=(obj); end

  # source://actioncable//lib/action_cable/server/worker.rb#18
  def executor; end

  # source://actioncable//lib/action_cable/server/worker.rb#31
  def halt; end

  # source://actioncable//lib/action_cable/server/worker.rb#57
  def invoke(receiver, method, *args, connection:, &block); end

  # source://actioncable//lib/action_cable/server/worker.rb#35
  def stopping?; end

  # source://actioncable//lib/action_cable/server/worker.rb#39
  def work(connection, &block); end

  private

  # source://actioncable//lib/action_cable/server/worker.rb#69
  def logger; end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks?; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _work_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _work_callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def connection; end

    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def connection=(obj); end
  end
end

# source://actioncable//lib/action_cable/server/worker/active_record_connection_management.rb#6
module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Concern

  # source://actioncable//lib/action_cable/server/worker/active_record_connection_management.rb#15
  def with_database_connections(&block); end
end

# source://actioncable//lib/action_cable/subscription_adapter.rb#4
module ActionCable::SubscriptionAdapter
  extend ::ActiveSupport::Autoload
end

# source://actioncable//lib/action_cable/subscription_adapter/async.rb#7
class ActionCable::SubscriptionAdapter::Async < ::ActionCable::SubscriptionAdapter::Inline
  private

  # source://actioncable//lib/action_cable/subscription_adapter/async.rb#9
  def new_subscriber_map; end
end

# source://actioncable//lib/action_cable/subscription_adapter/async.rb#13
class ActionCable::SubscriptionAdapter::Async::AsyncSubscriberMap < ::ActionCable::SubscriptionAdapter::SubscriberMap
  # source://actioncable//lib/action_cable/subscription_adapter/async.rb#14
  def initialize(event_loop); end

  # source://actioncable//lib/action_cable/subscription_adapter/async.rb#19
  def add_subscriber(*_arg0); end

  # source://actioncable//lib/action_cable/subscription_adapter/async.rb#23
  def invoke_callback(*_arg0); end
end

# source://actioncable//lib/action_cable/subscription_adapter/base.rb#5
class ActionCable::SubscriptionAdapter::Base
  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#8
  def initialize(server); end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#13
  def broadcast(channel, payload); end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#29
  def identifier; end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#6
  def logger; end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#6
  def server; end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#25
  def shutdown; end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#17
  def subscribe(channel, message_callback, success_callback = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/subscription_adapter/base.rb#21
  def unsubscribe(channel, message_callback); end
end

# source://actioncable//lib/action_cable/subscription_adapter/channel_prefix.rb#5
module ActionCable::SubscriptionAdapter::ChannelPrefix
  # source://actioncable//lib/action_cable/subscription_adapter/channel_prefix.rb#6
  def broadcast(channel, payload); end

  # source://actioncable//lib/action_cable/subscription_adapter/channel_prefix.rb#11
  def subscribe(channel, callback, success_callback = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/subscription_adapter/channel_prefix.rb#16
  def unsubscribe(channel, callback); end

  private

  # source://actioncable//lib/action_cable/subscription_adapter/channel_prefix.rb#23
  def channel_with_prefix(channel); end
end

# source://actioncable//lib/action_cable/subscription_adapter/inline.rb#5
class ActionCable::SubscriptionAdapter::Inline < ::ActionCable::SubscriptionAdapter::Base
  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#6
  def initialize(*_arg0); end

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#11
  def broadcast(channel, payload); end

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#23
  def shutdown; end

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#15
  def subscribe(channel, callback, success_callback = T.unsafe(nil)); end

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#19
  def unsubscribe(channel, callback); end

  private

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#32
  def new_subscriber_map; end

  # source://actioncable//lib/action_cable/subscription_adapter/inline.rb#28
  def subscriber_map; end
end

# source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#5
class ActionCable::SubscriptionAdapter::SubscriberMap
  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#6
  def initialize; end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#47
  def add_channel(channel, on_success); end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#11
  def add_subscriber(channel, subscriber, on_success); end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#36
  def broadcast(channel, message); end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#54
  def invoke_callback(callback, message); end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#51
  def remove_channel(channel); end

  # source://actioncable//lib/action_cable/subscription_adapter/subscriber_map.rb#25
  def remove_subscriber(channel, subscriber); end
end

# source://actioncable//lib/action_cable/subscription_adapter/test.rb#16
class ActionCable::SubscriptionAdapter::Test < ::ActionCable::SubscriptionAdapter::Async
  # source://actioncable//lib/action_cable/subscription_adapter/test.rb#17
  def broadcast(channel, payload); end

  # source://actioncable//lib/action_cable/subscription_adapter/test.rb#22
  def broadcasts(channel); end

  # source://actioncable//lib/action_cable/subscription_adapter/test.rb#30
  def clear; end

  # source://actioncable//lib/action_cable/subscription_adapter/test.rb#26
  def clear_messages(channel); end

  private

  # source://actioncable//lib/action_cable/subscription_adapter/test.rb#35
  def channels_data; end
end

# source://actioncable//lib/action_cable/test_case.rb#6
class ActionCable::TestCase < ::ActiveSupport::TestCase
  include ::ActionCable::TestHelper
end

# source://actioncable//lib/action_cable/test_helper.rb#5
module ActionCable::TestHelper
  # source://actioncable//lib/action_cable/test_helper.rb#16
  def after_teardown; end

  # source://actioncable//lib/action_cable/test_helper.rb#97
  def assert_broadcast_on(stream, data, &block); end

  # source://actioncable//lib/action_cable/test_helper.rb#45
  def assert_broadcasts(stream, number, &block); end

  # source://actioncable//lib/action_cable/test_helper.rb#78
  def assert_no_broadcasts(stream, &block); end

  # source://actioncable//lib/action_cable/test_helper.rb#6
  def before_setup; end

  # source://actioncable//lib/action_cable/test_helper.rb#126
  def broadcasts(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/test_helper.rb#126
  def clear_messages(*_arg0, **_arg1, &_arg2); end

  # source://actioncable//lib/action_cable/test_helper.rb#122
  def pubsub_adapter; end

  private

  # source://actioncable//lib/action_cable/test_helper.rb#129
  def broadcasts_size(channel); end
end

# source://actioncable//lib/action_cable/gem_version.rb#9
module ActionCable::VERSION; end

# source://actioncable//lib/action_cable/gem_version.rb#10
ActionCable::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/gem_version.rb#11
ActionCable::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://actioncable//lib/action_cable/gem_version.rb#13
ActionCable::VERSION::PRE = T.let(T.unsafe(nil), String)

# source://actioncable//lib/action_cable/gem_version.rb#15
ActionCable::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://actioncable//lib/action_cable/gem_version.rb#12
ActionCable::VERSION::TINY = T.let(T.unsafe(nil), Integer)
