# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack` gem.
# Please instead update this file by running `bin/tapioca gem rack`.


# source://rack//lib/rack/version.rb#14
module Rack
  class << self
    # source://rack//lib/rack/version.rb#31
    def release; end

    # source://rack//lib/rack/version.rb#23
    def version; end
  end
end

# source://rack//lib/rack.rb#65
module Rack::Auth; end

# source://rack//lib/rack/auth/abstract/handler.rb#11
class Rack::Auth::AbstractHandler
  # source://rack//lib/rack/auth/abstract/handler.rb#15
  def initialize(app, realm = T.unsafe(nil), &authenticator); end

  # source://rack//lib/rack/auth/abstract/handler.rb#13
  def realm; end

  # source://rack//lib/rack/auth/abstract/handler.rb#13
  def realm=(_arg0); end

  private

  # source://rack//lib/rack/auth/abstract/handler.rb#31
  def bad_request; end

  # source://rack//lib/rack/auth/abstract/handler.rb#22
  def unauthorized(www_authenticate = T.unsafe(nil)); end
end

# source://rack//lib/rack/auth/abstract/request.rb#7
class Rack::Auth::AbstractRequest
  # source://rack//lib/rack/auth/abstract/request.rb#9
  def initialize(env); end

  # source://rack//lib/rack/auth/abstract/request.rb#33
  def params; end

  # source://rack//lib/rack/auth/abstract/request.rb#25
  def parts; end

  # source://rack//lib/rack/auth/abstract/request.rb#17
  def provided?; end

  # source://rack//lib/rack/auth/abstract/request.rb#13
  def request; end

  # source://rack//lib/rack/auth/abstract/request.rb#29
  def scheme; end

  # source://rack//lib/rack/auth/abstract/request.rb#21
  def valid?; end

  private

  # source://rack//lib/rack/auth/abstract/request.rb#42
  def authorization_key; end
end

# source://rack//lib/rack/auth/abstract/request.rb#40
Rack::Auth::AbstractRequest::AUTHORIZATION_KEYS = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/auth/basic.rb#14
class Rack::Auth::Basic < ::Rack::Auth::AbstractHandler
  # source://rack//lib/rack/auth/basic.rb#16
  def call(env); end

  private

  # source://rack//lib/rack/auth/basic.rb#35
  def challenge; end

  # source://rack//lib/rack/auth/basic.rb#39
  def valid?(auth); end
end

# source://rack//lib/rack/auth/basic.rb#43
class Rack::Auth::Basic::Request < ::Rack::Auth::AbstractRequest
  # source://rack//lib/rack/auth/basic.rb#44
  def basic?; end

  # source://rack//lib/rack/auth/basic.rb#48
  def credentials; end

  # source://rack//lib/rack/auth/basic.rb#52
  def username; end
end

# source://rack//lib/rack/auth/digest.rb#12
module Rack::Auth::Digest; end

# source://rack//lib/rack/auth/digest.rb#144
class Rack::Auth::Digest::MD5 < ::Rack::Auth::AbstractHandler
  # source://rack//lib/rack/auth/digest.rb#150
  def initialize(app, realm = T.unsafe(nil), opaque = T.unsafe(nil), &authenticator); end

  # source://rack//lib/rack/auth/digest.rb#163
  def call(env); end

  # source://rack//lib/rack/auth/digest.rb#146
  def opaque; end

  # source://rack//lib/rack/auth/digest.rb#146
  def opaque=(_arg0); end

  # source://rack//lib/rack/auth/digest.rb#148
  def passwords_hashed=(_arg0); end

  # source://rack//lib/rack/auth/digest.rb#159
  def passwords_hashed?; end

  private

  # source://rack//lib/rack/auth/digest.rb#238
  def A1(auth, password); end

  # source://rack//lib/rack/auth/digest.rb#242
  def A2(auth); end

  # source://rack//lib/rack/auth/digest.rb#228
  def H(data); end

  # source://rack//lib/rack/auth/digest.rb#234
  def KD(secret, data); end

  # source://rack//lib/rack/auth/digest.rb#203
  def challenge(hash = T.unsafe(nil)); end

  # source://rack//lib/rack/auth/digest.rb#246
  def digest(auth, password); end

  # source://rack//lib/rack/auth/digest.rb#228
  def md5(data); end

  # source://rack//lib/rack/auth/digest.rb#192
  def params(hash = T.unsafe(nil)); end

  # source://rack//lib/rack/auth/digest.rb#207
  def valid?(auth); end

  # source://rack//lib/rack/auth/digest.rb#223
  def valid_digest?(auth); end

  # source://rack//lib/rack/auth/digest.rb#219
  def valid_nonce?(auth); end

  # source://rack//lib/rack/auth/digest.rb#215
  def valid_opaque?(auth); end

  # source://rack//lib/rack/auth/digest.rb#211
  def valid_qop?(auth); end
end

# source://rack//lib/rack/auth/digest.rb#190
Rack::Auth::Digest::MD5::QOP = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/auth/digest.rb#21
class Rack::Auth::Digest::Nonce
  # source://rack//lib/rack/auth/digest.rb#31
  def initialize(timestamp = T.unsafe(nil), given_digest = T.unsafe(nil)); end

  # source://rack//lib/rack/auth/digest.rb#39
  def digest; end

  # source://rack//lib/rack/auth/digest.rb#51
  def fresh?; end

  # source://rack//lib/rack/auth/digest.rb#47
  def stale?; end

  # source://rack//lib/rack/auth/digest.rb#35
  def to_s; end

  # source://rack//lib/rack/auth/digest.rb#43
  def valid?; end

  class << self
    # source://rack//lib/rack/auth/digest.rb#27
    def parse(string); end

    # source://rack//lib/rack/auth/digest.rb#24
    def private_key; end

    # source://rack//lib/rack/auth/digest.rb#24
    def private_key=(_arg0); end

    # source://rack//lib/rack/auth/digest.rb#24
    def time_limit; end

    # source://rack//lib/rack/auth/digest.rb#24
    def time_limit=(_arg0); end
  end
end

# source://rack//lib/rack/auth/digest.rb#57
class Rack::Auth::Digest::Params < ::Hash
  # source://rack//lib/rack/auth/digest.rb#76
  def initialize; end

  # source://rack//lib/rack/auth/digest.rb#82
  def [](k); end

  # source://rack//lib/rack/auth/digest.rb#86
  def []=(k, v); end

  # source://rack//lib/rack/auth/digest.rb#98
  def quote(str); end

  # source://rack//lib/rack/auth/digest.rb#92
  def to_s; end

  class << self
    # source://rack//lib/rack/auth/digest.rb#66
    def dequote(str); end

    # source://rack//lib/rack/auth/digest.rb#59
    def parse(str); end

    # source://rack//lib/rack/auth/digest.rb#72
    def split_header_value(str); end
  end
end

# source://rack//lib/rack/auth/digest.rb#90
Rack::Auth::Digest::Params::UNQUOTED = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/auth/digest.rb#104
class Rack::Auth::Digest::Request < ::Rack::Auth::AbstractRequest
  # source://rack//lib/rack/auth/digest.rb#113
  def correct_uri?; end

  # source://rack//lib/rack/auth/digest.rb#109
  def digest?; end

  # source://rack//lib/rack/auth/digest.rb#105
  def method; end

  # source://rack//lib/rack/auth/digest.rb#129
  def method_missing(sym, *args); end

  # source://rack//lib/rack/auth/digest.rb#117
  def nonce; end

  # source://rack//lib/rack/auth/digest.rb#121
  def params; end

  # source://rack//lib/rack/auth/digest.rb#125
  def respond_to?(sym, *_arg1); end
end

# source://rack//lib/rack/body_proxy.rb#7
class Rack::BodyProxy
  # source://rack//lib/rack/body_proxy.rb#10
  def initialize(body, &block); end

  # source://rack//lib/rack/body_proxy.rb#28
  def close; end

  # source://rack//lib/rack/body_proxy.rb#40
  def closed?; end

  # source://rack//lib/rack/body_proxy.rb#45
  def method_missing(method_name, *args, **_arg2, &block); end

  private

  # source://rack//lib/rack/body_proxy.rb#17
  def respond_to_missing?(method_name, include_all = T.unsafe(nil)); end
end

# source://rack//lib/rack/builder.rb#33
class Rack::Builder
  # source://rack//lib/rack/builder.rb#111
  def initialize(default_app = T.unsafe(nil), &block); end

  # source://rack//lib/rack/builder.rb#263
  def call(env); end

  # source://rack//lib/rack/builder.rb#246
  def freeze_app; end

  # source://rack//lib/rack/builder.rb#239
  def map(path, &block); end

  # source://rack//lib/rack/builder.rb#180
  def run(app = T.unsafe(nil), &block); end

  # source://rack//lib/rack/builder.rb#251
  def to_app; end

  # source://rack//lib/rack/builder.rb#146
  def use(middleware, *args, **_arg2, &block); end

  # source://rack//lib/rack/builder.rb#196
  def warmup(prc = T.unsafe(nil), &block); end

  private

  # source://rack//lib/rack/builder.rb#271
  def generate_map(default_app, mapping); end

  class << self
    # source://rack//lib/rack/builder.rb#123
    def app(default_app = T.unsafe(nil), &block); end

    # source://rack//lib/rack/builder.rb#84
    def load_file(path); end

    # source://rack//lib/rack/builder.rb#99
    def new_from_string(builder_script, file = T.unsafe(nil)); end

    # source://rack//lib/rack/builder.rb#62
    def parse_file(path); end
  end
end

# source://rack//lib/rack/builder.rb#36
Rack::Builder::UTF_8_BOM = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#19
Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#20
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#21
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/cascade.rb#11
class Rack::Cascade
  # source://rack//lib/rack/cascade.rb#24
  def initialize(apps, cascade_for = T.unsafe(nil)); end

  # source://rack//lib/rack/cascade.rb#59
  def <<(app); end

  # source://rack//lib/rack/cascade.rb#59
  def add(app); end

  # source://rack//lib/rack/cascade.rb#16
  def apps; end

  # source://rack//lib/rack/cascade.rb#35
  def call(env); end

  # source://rack//lib/rack/cascade.rb#64
  def include?(app); end
end

# source://rack//lib/rack/cascade.rb#13
Rack::Cascade::NotFound = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/chunked.rb#25
class Rack::Chunked
  include ::Rack::Utils

  # source://rack//lib/rack/chunked.rb#82
  def initialize(app); end

  # source://rack//lib/rack/chunked.rb#101
  def call(env); end

  # source://rack//lib/rack/chunked.rb#87
  def chunkable_version?(ver); end
end

# source://rack//lib/rack/chunked.rb#29
class Rack::Chunked::Body
  # source://rack//lib/rack/chunked.rb#34
  def initialize(body); end

  # source://rack//lib/rack/chunked.rb#54
  def close; end

  # source://rack//lib/rack/chunked.rb#40
  def each(&block); end

  private

  # source://rack//lib/rack/chunked.rb#61
  def yield_trailers; end
end

# source://rack//lib/rack/chunked.rb#31
Rack::Chunked::Body::TAIL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/chunked.rb#30
Rack::Chunked::Body::TERM = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/chunked.rb#71
class Rack::Chunked::TrailerBody < ::Rack::Chunked::Body
  private

  # source://rack//lib/rack/chunked.rb#75
  def yield_trailers; end
end

# source://rack//lib/rack/common_logger.rb#13
class Rack::CommonLogger
  # source://rack//lib/rack/common_logger.rb#29
  def initialize(app, logger = T.unsafe(nil)); end

  # source://rack//lib/rack/common_logger.rb#41
  def call(env); end

  private

  # source://rack//lib/rack/common_logger.rb#83
  def extract_content_length(headers); end

  # source://rack//lib/rack/common_logger.rb#52
  def log(env, status, response_headers, began_at); end
end

# source://rack//lib/rack/common_logger.rb#23
Rack::CommonLogger::FORMAT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/conditional_get.rb#21
class Rack::ConditionalGet
  # source://rack//lib/rack/conditional_get.rb#22
  def initialize(app); end

  # source://rack//lib/rack/conditional_get.rb#28
  def call(env); end

  private

  # source://rack//lib/rack/conditional_get.rb#62
  def etag_matches?(none_match, headers); end

  # source://rack//lib/rack/conditional_get.rb#51
  def fresh?(env, headers); end

  # source://rack//lib/rack/conditional_get.rb#68
  def modified_since?(modified_since, headers); end

  # source://rack//lib/rack/conditional_get.rb#75
  def to_rfc2822(since); end
end

# source://rack//lib/rack/config.rb#11
class Rack::Config
  # source://rack//lib/rack/config.rb#12
  def initialize(app, &block); end

  # source://rack//lib/rack/config.rb#17
  def call(env); end
end

# source://rack//lib/rack/content_length.rb#12
class Rack::ContentLength
  include ::Rack::Utils

  # source://rack//lib/rack/content_length.rb#15
  def initialize(app); end

  # source://rack//lib/rack/content_length.rb#19
  def call(env); end
end

# source://rack//lib/rack/content_type.rb#15
class Rack::ContentType
  include ::Rack::Utils

  # source://rack//lib/rack/content_type.rb#18
  def initialize(app, content_type = T.unsafe(nil)); end

  # source://rack//lib/rack/content_type.rb#23
  def call(env); end
end

# source://rack//lib/rack/constants.rb#32
Rack::DELETE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/deflater.rb#28
class Rack::Deflater
  # source://rack//lib/rack/deflater.rb#39
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack//lib/rack/deflater.rb#46
  def call(env); end

  private

  # source://rack//lib/rack/deflater.rb#136
  def should_deflate?(env, status, headers, body); end
end

# source://rack//lib/rack/deflater.rb#83
class Rack::Deflater::GzipStream
  # source://rack//lib/rack/deflater.rb#92
  def initialize(body, mtime, sync); end

  # source://rack//lib/rack/deflater.rb#128
  def close; end

  # source://rack//lib/rack/deflater.rb#99
  def each(&block); end

  # source://rack//lib/rack/deflater.rb#123
  def write(data); end
end

# source://rack//lib/rack/deflater.rb#85
Rack::Deflater::GzipStream::BUFFER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/directory.rb#19
class Rack::Directory
  # source://rack//lib/rack/directory.rb#83
  def initialize(root, app = T.unsafe(nil)); end

  # source://rack//lib/rack/directory.rb#89
  def call(env); end

  # source://rack//lib/rack/directory.rb#109
  def check_bad_request(path_info); end

  # source://rack//lib/rack/directory.rb#119
  def check_forbidden(path_info); end

  # source://rack//lib/rack/directory.rb#181
  def entity_not_found(path_info); end

  # source://rack//lib/rack/directory.rb#197
  def filesize_format(int); end

  # source://rack//lib/rack/directory.rb#96
  def get(env); end

  # source://rack//lib/rack/directory.rb#130
  def list_directory(path_info, path, script_name); end

  # source://rack//lib/rack/directory.rb#171
  def list_path(env, path, path_info, script_name); end

  # source://rack//lib/rack/directory.rb#80
  def root; end

  # source://rack//lib/rack/directory.rb#163
  def stat(path); end
end

# source://rack//lib/rack/directory.rb#20
Rack::Directory::DIR_FILE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/directory.rb#43
Rack::Directory::DIR_PAGE_FOOTER = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/directory.rb#21
Rack::Directory::DIR_PAGE_HEADER = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/directory.rb#51
class Rack::Directory::DirectoryBody < ::Struct
  # source://rack//lib/rack/directory.rb#53
  def each; end

  private

  # source://rack//lib/rack/directory.rb#73
  def DIR_FILE_escape(htmls); end
end

# source://rack//lib/rack/directory.rb#189
Rack::Directory::FILESIZE_FORMAT = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/constants.rb#22
Rack::ETAG = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/etag.rb#18
class Rack::ETag
  # source://rack//lib/rack/etag.rb#22
  def initialize(app, no_cache_control = T.unsafe(nil), cache_control = T.unsafe(nil)); end

  # source://rack//lib/rack/etag.rb#28
  def call(env); end

  private

  # source://rack//lib/rack/etag.rb#58
  def digest_body(body); end

  # source://rack//lib/rack/etag.rb#50
  def etag_status?(status); end

  # source://rack//lib/rack/etag.rb#54
  def skip_caching?(headers); end
end

# source://rack//lib/rack/etag.rb#20
Rack::ETag::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/etag.rb#19
Rack::ETag::ETAG_STRING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#23
Rack::EXPIRES = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/events.rb#61
class Rack::Events
  # source://rack//lib/rack/events.rb#106
  def initialize(app, handlers); end

  # source://rack//lib/rack/events.rb#111
  def call(env); end

  private

  # source://rack//lib/rack/events.rb#149
  def make_request(env); end

  # source://rack//lib/rack/events.rb#153
  def make_response(status, headers, body); end

  # source://rack//lib/rack/events.rb#137
  def on_commit(request, response); end

  # source://rack//lib/rack/events.rb#133
  def on_error(request, response, e); end

  # source://rack//lib/rack/events.rb#145
  def on_finish(request, response); end

  # source://rack//lib/rack/events.rb#141
  def on_start(request, response); end
end

# source://rack//lib/rack/events.rb#62
module Rack::Events::Abstract
  # source://rack//lib/rack/events.rb#66
  def on_commit(req, res); end

  # source://rack//lib/rack/events.rb#75
  def on_error(req, res, e); end

  # source://rack//lib/rack/events.rb#72
  def on_finish(req, res); end

  # source://rack//lib/rack/events.rb#69
  def on_send(req, res); end

  # source://rack//lib/rack/events.rb#63
  def on_start(req, res); end
end

# source://rack//lib/rack/events.rb#95
class Rack::Events::BufferedResponse < ::Rack::Response::Raw
  # source://rack//lib/rack/events.rb#98
  def initialize(status, headers, body); end

  # source://rack//lib/rack/events.rb#96
  def body; end

  # source://rack//lib/rack/events.rb#103
  def to_a; end
end

# source://rack//lib/rack/events.rb#79
class Rack::Events::EventedBodyProxy < ::Rack::BodyProxy
  # source://rack//lib/rack/events.rb#82
  def initialize(body, request, response, handlers, &block); end

  # source://rack//lib/rack/events.rb#89
  def each; end

  # source://rack//lib/rack/events.rb#80
  def request; end

  # source://rack//lib/rack/events.rb#80
  def response; end
end

# source://rack//lib/rack/file.rb#8
Rack::File = Rack::Files

# source://rack//lib/rack/files.rb#20
class Rack::Files
  # source://rack//lib/rack/files.rb#27
  def initialize(root, headers = T.unsafe(nil), default_mime = T.unsafe(nil)); end

  # source://rack//lib/rack/files.rb#34
  def call(env); end

  # source://rack//lib/rack/files.rb#39
  def get(env); end

  # source://rack//lib/rack/files.rb#25
  def root; end

  # source://rack//lib/rack/files.rb#68
  def serving(request, path); end

  private

  # source://rack//lib/rack/files.rb#190
  def fail(status, body, headers = T.unsafe(nil)); end

  # source://rack//lib/rack/files.rb#209
  def filesize(path); end

  # source://rack//lib/rack/files.rb#205
  def mime_type(path, default_mime); end
end

# source://rack//lib/rack/files.rb#21
Rack::Files::ALLOWED_VERBS = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/files.rb#22
Rack::Files::ALLOW_HEADER = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/files.rb#121
class Rack::Files::BaseIterator
  # source://rack//lib/rack/files.rb#124
  def initialize(path, ranges, options); end

  # source://rack//lib/rack/files.rb#144
  def bytesize; end

  # source://rack//lib/rack/files.rb#153
  def close; end

  # source://rack//lib/rack/files.rb#130
  def each; end

  # source://rack//lib/rack/files.rb#122
  def options; end

  # source://rack//lib/rack/files.rb#122
  def path; end

  # source://rack//lib/rack/files.rb#122
  def ranges; end

  private

  # source://rack//lib/rack/files.rb#171
  def each_range_part(file, range); end

  # source://rack//lib/rack/files.rb#157
  def multipart?; end

  # source://rack//lib/rack/files.rb#161
  def multipart_heading(range); end
end

# source://rack//lib/rack/files.rb#184
class Rack::Files::Iterator < ::Rack::Files::BaseIterator
  # source://rack//lib/rack/files.rb#122
  def to_path; end
end

# source://rack//lib/rack/files.rb#23
Rack::Files::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/recursive.rb#14
class Rack::ForwardRequest < ::Exception
  # source://rack//lib/rack/recursive.rb#17
  def initialize(url, env = T.unsafe(nil)); end

  # source://rack//lib/rack/recursive.rb#15
  def env; end

  # source://rack//lib/rack/recursive.rb#15
  def url; end
end

# source://rack//lib/rack/constants.rb#28
Rack::GET = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#33
Rack::HEAD = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#7
Rack::HTTPS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#16
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#5
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#6
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/head.rb#9
class Rack::Head
  # source://rack//lib/rack/head.rb#10
  def initialize(app); end

  # source://rack//lib/rack/head.rb#14
  def call(env); end
end

# source://rack//lib/rack/headers.rb#6
class Rack::Headers < ::Hash
  # source://rack//lib/rack/headers.rb#26
  def [](key); end

  # source://rack//lib/rack/headers.rb#30
  def []=(key, value); end

  # source://rack//lib/rack/headers.rb#35
  def assoc(key); end

  # source://rack//lib/rack/headers.rb#39
  def compare_by_identity; end

  # source://rack//lib/rack/headers.rb#43
  def delete(key); end

  # source://rack//lib/rack/headers.rb#47
  def dig(key, *a); end

  # source://rack//lib/rack/headers.rb#143
  def except(*a); end

  # source://rack//lib/rack/headers.rb#51
  def fetch(key, *default, &block); end

  # source://rack//lib/rack/headers.rb#56
  def fetch_values(*a); end

  # source://rack//lib/rack/headers.rb#60
  def has_key?(key); end

  # source://rack//lib/rack/headers.rb#60
  def include?(key); end

  # source://rack//lib/rack/headers.rb#67
  def invert; end

  # source://rack//lib/rack/headers.rb#60
  def key?(key); end

  # source://rack//lib/rack/headers.rb#60
  def member?(key); end

  # source://rack//lib/rack/headers.rb#73
  def merge(hash, &block); end

  # source://rack//lib/rack/headers.rb#102
  def merge!(hash, &block); end

  # source://rack//lib/rack/headers.rb#77
  def reject(&block); end

  # source://rack//lib/rack/headers.rb#83
  def replace(hash); end

  # source://rack//lib/rack/headers.rb#88
  def select(&block); end

  # source://rack//lib/rack/headers.rb#121
  def slice(*a); end

  # source://rack//lib/rack/headers.rb#30
  def store(key, value); end

  # source://rack//lib/rack/headers.rb#94
  def to_proc; end

  # source://rack//lib/rack/headers.rb#127
  def transform_keys(&block); end

  # source://rack//lib/rack/headers.rb#131
  def transform_keys!; end

  # source://rack//lib/rack/headers.rb#98
  def transform_values(&block); end

  # source://rack//lib/rack/headers.rb#102
  def update(hash, &block); end

  # source://rack//lib/rack/headers.rb#114
  def values_at(*keys); end

  private

  # source://rack//lib/rack/headers.rb#150
  def downcase_key(key); end

  class << self
    # source://rack//lib/rack/headers.rb#7
    def [](*items); end
  end
end

# source://rack//lib/rack/constants.rb#35
Rack::LINK = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/lint.rb#12
class Rack::Lint
  # source://rack//lib/rack/lint.rb#13
  def initialize(app); end

  # source://rack//lib/rack/lint.rb#34
  def call(env = T.unsafe(nil)); end
end

# source://rack//lib/rack/lint.rb#19
class Rack::Lint::LintError < ::RuntimeError; end

# source://rack//lib/rack/lint.rb#38
class Rack::Lint::Wrapper
  # source://rack//lib/rack/lint.rb#39
  def initialize(app, env); end

  # source://rack//lib/rack/lint.rb#855
  def call(stream); end

  # source://rack//lib/rack/lint.rb#693
  def check_content_length(status, headers); end

  # source://rack//lib/rack/lint.rb#677
  def check_content_type(status, headers); end

  # source://rack//lib/rack/lint.rb#97
  def check_environment(env); end

  # source://rack//lib/rack/lint.rb#491
  def check_error(error); end

  # source://rack//lib/rack/lint.rb#667
  def check_header_value(key, value); end

  # source://rack//lib/rack/lint.rb#627
  def check_headers(headers); end

  # source://rack//lib/rack/lint.rb#551
  def check_hijack(env); end

  # source://rack//lib/rack/lint.rb#579
  def check_hijack_response(headers, env); end

  # source://rack//lib/rack/lint.rb#387
  def check_input(input); end

  # source://rack//lib/rack/lint.rb#616
  def check_status(status); end

  # source://rack//lib/rack/lint.rb#744
  def close; end

  # source://rack//lib/rack/lint.rb#778
  def each; end

  # source://rack//lib/rack/lint.rb#826
  def respond_to?(name, *_arg1); end

  # source://rack//lib/rack/lint.rb#54
  def response; end

  # source://rack//lib/rack/lint.rb#842
  def to_ary; end

  # source://rack//lib/rack/lint.rb#822
  def to_path; end

  # source://rack//lib/rack/lint.rb#706
  def verify_content_length(size); end

  # source://rack//lib/rack/lint.rb#760
  def verify_to_path; end
end

# source://rack//lib/rack/lint.rb#820
Rack::Lint::Wrapper::BODY_METHODS = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/lint.rb#500
class Rack::Lint::Wrapper::ErrorWrapper
  # source://rack//lib/rack/lint.rb#501
  def initialize(error); end

  # source://rack//lib/rack/lint.rb#523
  def close(*args); end

  # source://rack//lib/rack/lint.rb#518
  def flush; end

  # source://rack//lib/rack/lint.rb#506
  def puts(str); end

  # source://rack//lib/rack/lint.rb#511
  def write(str); end
end

# source://rack//lib/rack/lint.rb#405
class Rack::Lint::Wrapper::InputWrapper
  # source://rack//lib/rack/lint.rb#406
  def initialize(input); end

  # source://rack//lib/rack/lint.rb#483
  def close(*args); end

  # source://rack//lib/rack/lint.rb#471
  def each(*args); end

  # source://rack//lib/rack/lint.rb#412
  def gets(*args); end

  # source://rack//lib/rack/lint.rb#438
  def read(*args); end
end

# source://rack//lib/rack/lint.rb#875
class Rack::Lint::Wrapper::StreamWrapper
  extend ::Forwardable

  # source://rack//lib/rack/lint.rb#890
  def initialize(stream); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def <<(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_read(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close_write(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def closed?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def flush(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def read(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def write(*args, **_arg1, &block); end
end

# source://rack//lib/rack/lint.rb#883
Rack::Lint::Wrapper::StreamWrapper::REQUIRED_METHODS = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/lock.rb#8
class Rack::Lock
  # source://rack//lib/rack/lock.rb#9
  def initialize(app, mutex = T.unsafe(nil)); end

  # source://rack//lib/rack/lock.rb#13
  def call(env); end

  private

  # source://rack//lib/rack/lock.rb#25
  def unlock; end
end

# source://rack//lib/rack/logger.rb#9
class Rack::Logger
  # source://rack//lib/rack/logger.rb#10
  def initialize(app, level = T.unsafe(nil)); end

  # source://rack//lib/rack/logger.rb#14
  def call(env); end
end

# source://rack//lib/rack/media_type.rb#6
class Rack::MediaType
  class << self
    # source://rack//lib/rack/media_type.rb#30
    def params(content_type); end

    # source://rack//lib/rack/media_type.rb#16
    def type(content_type); end

    private

    # source://rack//lib/rack/media_type.rb#43
    def strip_doublequotes(str); end
  end
end

# source://rack//lib/rack/media_type.rb#7
Rack::MediaType::SPLIT_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/method_override.rb#8
class Rack::MethodOverride
  # source://rack//lib/rack/method_override.rb#15
  def initialize(app); end

  # source://rack//lib/rack/method_override.rb#19
  def call(env); end

  # source://rack//lib/rack/method_override.rb#31
  def method_override(env); end

  private

  # source://rack//lib/rack/method_override.rb#44
  def allowed_methods; end

  # source://rack//lib/rack/method_override.rb#48
  def method_override_param(req); end
end

# source://rack//lib/rack/method_override.rb#13
Rack::MethodOverride::ALLOWED_METHODS = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/method_override.rb#9
Rack::MethodOverride::HTTP_METHODS = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/method_override.rb#12
Rack::MethodOverride::HTTP_METHOD_OVERRIDE_HEADER = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/method_override.rb#11
Rack::MethodOverride::METHOD_OVERRIDE_PARAM_KEY = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/mime.rb#4
module Rack::Mime
  private

  # source://rack//lib/rack/mime.rb#30
  def match?(value, matcher); end

  # source://rack//lib/rack/mime.rb#18
  def mime_type(ext, fallback = T.unsafe(nil)); end

  class << self
    # source://rack//lib/rack/mime.rb#30
    def match?(value, matcher); end

    # source://rack//lib/rack/mime.rb#18
    def mime_type(ext, fallback = T.unsafe(nil)); end
  end
end

# source://rack//lib/rack/mime.rb#51
Rack::Mime::MIME_TYPES = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/mock_request.rb#23
class Rack::MockRequest
  # source://rack//lib/rack/mock_request.rb#49
  def initialize(app); end

  # source://rack//lib/rack/mock_request.rb#62
  def delete(uri, opts = T.unsafe(nil)); end

  # source://rack//lib/rack/mock_request.rb#54
  def get(uri, opts = T.unsafe(nil)); end

  # source://rack//lib/rack/mock_request.rb#64
  def head(uri, opts = T.unsafe(nil)); end

  # source://rack//lib/rack/mock_request.rb#66
  def options(uri, opts = T.unsafe(nil)); end

  # source://rack//lib/rack/mock_request.rb#60
  def patch(uri, opts = T.unsafe(nil)); end

  # source://rack//lib/rack/mock_request.rb#56
  def post(uri, opts = T.unsafe(nil)); end

  # source://rack//lib/rack/mock_request.rb#58
  def put(uri, opts = T.unsafe(nil)); end

  # source://rack//lib/rack/mock_request.rb#71
  def request(method = T.unsafe(nil), uri = T.unsafe(nil), opts = T.unsafe(nil)); end

  class << self
    # source://rack//lib/rack/mock_request.rb#103
    def env_for(uri = T.unsafe(nil), opts = T.unsafe(nil)); end

    # source://rack//lib/rack/mock_request.rb#89
    def parse_uri_rfc2396(uri); end
  end
end

# source://rack//lib/rack/mock_request.rb#44
Rack::MockRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/mock_request.rb#27
class Rack::MockRequest::FatalWarner
  # source://rack//lib/rack/mock_request.rb#36
  def flush; end

  # source://rack//lib/rack/mock_request.rb#28
  def puts(warning); end

  # source://rack//lib/rack/mock_request.rb#39
  def string; end

  # source://rack//lib/rack/mock_request.rb#32
  def write(warning); end
end

# source://rack//lib/rack/mock_request.rb#24
class Rack::MockRequest::FatalWarning < ::RuntimeError; end

# source://rack//lib/rack/mock_response.rb#13
class Rack::MockResponse < ::Rack::Response
  # source://rack//lib/rack/mock_response.rb#24
  def initialize(status, headers, body, errors = T.unsafe(nil)); end

  # source://rack//lib/rack/mock_response.rb#39
  def =~(other); end

  # source://rack//lib/rack/mock_response.rb#47
  def body; end

  # source://rack//lib/rack/mock_response.rb#73
  def cookie(name); end

  # source://rack//lib/rack/mock_response.rb#19
  def cookies; end

  # source://rack//lib/rack/mock_response.rb#69
  def empty?; end

  # source://rack//lib/rack/mock_response.rb#22
  def errors; end

  # source://rack//lib/rack/mock_response.rb#22
  def errors=(_arg0); end

  # source://rack//lib/rack/mock_response.rb#43
  def match(other); end

  # source://rack//lib/rack/mock_response.rb#19
  def original_headers; end

  private

  # source://rack//lib/rack/mock_response.rb#102
  def identify_cookie_attributes(cookie_filling); end

  # source://rack//lib/rack/mock_response.rb#79
  def parse_cookies_from_header; end

  class << self
    def [](*_arg0); end
  end
end

# source://rack//lib/rack/multipart/parser.rb#8
module Rack::Multipart
  class << self
    # source://rack//lib/rack/multipart.rb#39
    def build_multipart(params, first = T.unsafe(nil)); end

    # source://rack//lib/rack/multipart.rb#35
    def extract_multipart(request, params = T.unsafe(nil)); end

    # source://rack//lib/rack/multipart.rb#17
    def parse_multipart(env, params = T.unsafe(nil)); end
  end
end

# source://rack//lib/rack/multipart/parser.rb#32
Rack::Multipart::ATTRIBUTE = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#31
Rack::Multipart::ATTRIBUTE_CHAR = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#26
Rack::Multipart::BROKEN = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#24
Rack::Multipart::CONDISP = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#43
Rack::Multipart::DISPPARM = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#21
Rack::Multipart::EOL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/multipart/parser.rb#39
Rack::Multipart::EXTENDED_INITIAL_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#41
Rack::Multipart::EXTENDED_INITIAL_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#40
Rack::Multipart::EXTENDED_INITIAL_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#36
Rack::Multipart::EXTENDED_OTHER_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#38
Rack::Multipart::EXTENDED_OTHER_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#37
Rack::Multipart::EXTENDED_OTHER_VALUE = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#42
Rack::Multipart::EXTENDED_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#15
class Rack::Multipart::EmptyContentError < ::EOFError; end

# source://rack//lib/rack/multipart/parser.rb#19
class Rack::Multipart::Error < ::StandardError; end

# source://rack//lib/rack/multipart/generator.rb#7
class Rack::Multipart::Generator
  # source://rack//lib/rack/multipart/generator.rb#8
  def initialize(params, first = T.unsafe(nil)); end

  # source://rack//lib/rack/multipart/generator.rb#16
  def dump; end

  private

  # source://rack//lib/rack/multipart/generator.rb#89
  def content_for_other(file, name); end

  # source://rack//lib/rack/multipart/generator.rb#77
  def content_for_tempfile(io, file, name); end

  # source://rack//lib/rack/multipart/generator.rb#52
  def flattened_params; end

  # source://rack//lib/rack/multipart/generator.rb#37
  def multipart?; end
end

# source://rack//lib/rack/multipart/parser.rb#22
Rack::Multipart::MULTIPART = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart.rb#14
Rack::Multipart::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/multipart/parser.rb#28
Rack::Multipart::MULTIPART_CONTENT_DISPOSITION = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#29
Rack::Multipart::MULTIPART_CONTENT_ID = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#27
Rack::Multipart::MULTIPART_CONTENT_TYPE = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#9
class Rack::Multipart::MultipartPartLimitError < ::Errno::EMFILE; end

# source://rack//lib/rack/multipart/parser.rb#11
class Rack::Multipart::MultipartTotalPartLimitError < ::StandardError; end

# source://rack//lib/rack/multipart/parser.rb#46
class Rack::Multipart::Parser
  # source://rack//lib/rack/multipart/parser.rb#205
  def initialize(boundary, tempfile, bufsize, query_parser); end

  # source://rack//lib/rack/multipart/parser.rb#221
  def parse(io); end

  # source://rack//lib/rack/multipart/parser.rb#244
  def result; end

  # source://rack//lib/rack/multipart/parser.rb#203
  def state; end

  private

  # source://rack//lib/rack/multipart/parser.rb#354
  def consume_boundary; end

  # source://rack//lib/rack/multipart/parser.rb#256
  def dequote(str); end

  # source://rack//lib/rack/multipart/parser.rb#363
  def get_filename(head); end

  # source://rack//lib/rack/multipart/parser.rb#298
  def handle_consume_token; end

  # source://rack//lib/rack/multipart/parser.rb#435
  def handle_empty_content!(content); end

  # source://rack//lib/rack/multipart/parser.rb#275
  def handle_fast_forward; end

  # source://rack//lib/rack/multipart/parser.rb#331
  def handle_mime_body; end

  # source://rack//lib/rack/multipart/parser.rb#308
  def handle_mime_head; end

  # source://rack//lib/rack/multipart/parser.rb#262
  def read_data(io, outbuf); end

  # source://rack//lib/rack/multipart/parser.rb#401
  def tag_multipart_encoding(filename, content_type, name, body); end

  class << self
    # source://rack//lib/rack/multipart/parser.rb#92
    def parse(io, content_length, content_type, tmpfile, bufsize, qp); end

    # source://rack//lib/rack/multipart/parser.rb#85
    def parse_boundary(content_type); end
  end
end

# source://rack//lib/rack/multipart/parser.rb#47
Rack::Multipart::Parser::BUFSIZE = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/multipart/parser.rb#53
class Rack::Multipart::Parser::BoundedIO
  # source://rack//lib/rack/multipart/parser.rb#54
  def initialize(io, content_length); end

  # source://rack//lib/rack/multipart/parser.rb#60
  def read(size, outbuf = T.unsafe(nil)); end
end

# source://rack//lib/rack/multipart/parser.rb#398
Rack::Multipart::Parser::CHARSET = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/multipart/parser.rb#112
class Rack::Multipart::Parser::Collector
  include ::Enumerable

  # source://rack//lib/rack/multipart/parser.rb#148
  def initialize(tempfile); end

  # source://rack//lib/rack/multipart/parser.rb#154
  def each; end

  # source://rack//lib/rack/multipart/parser.rb#174
  def on_mime_body(mime_index, content); end

  # source://rack//lib/rack/multipart/parser.rb#178
  def on_mime_finish(mime_index); end

  # source://rack//lib/rack/multipart/parser.rb#158
  def on_mime_head(mime_index, head, filename, content_type, name); end

  private

  # source://rack//lib/rack/multipart/parser.rb#183
  def check_part_limits; end
end

# source://rack//lib/rack/multipart/parser.rb#136
class Rack::Multipart::Parser::Collector::BufferPart < ::Rack::Multipart::Parser::Collector::MimePart
  # source://rack//lib/rack/multipart/parser.rb#138
  def close; end

  # source://rack//lib/rack/multipart/parser.rb#137
  def file?; end
end

# source://rack//lib/rack/multipart/parser.rb#113
class Rack::Multipart::Parser::Collector::MimePart < ::Struct
  # source://rack//lib/rack/multipart/parser.rb#114
  def get_data; end
end

# source://rack//lib/rack/multipart/parser.rb#141
class Rack::Multipart::Parser::Collector::TempfilePart < ::Rack::Multipart::Parser::Collector::MimePart
  # source://rack//lib/rack/multipart/parser.rb#143
  def close; end

  # source://rack//lib/rack/multipart/parser.rb#142
  def file?; end
end

# source://rack//lib/rack/multipart/parser.rb#83
Rack::Multipart::Parser::EMPTY = T.let(T.unsafe(nil), Rack::Multipart::Parser::MultipartInfo)

# source://rack//lib/rack/multipart/parser.rb#82
class Rack::Multipart::Parser::MultipartInfo < ::Struct
  def params; end
  def params=(_); end
  def tmp_files; end
  def tmp_files=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rack//lib/rack/multipart/parser.rb#49
Rack::Multipart::Parser::TEMPFILE_FACTORY = T.let(T.unsafe(nil), Proc)

# source://rack//lib/rack/multipart/parser.rb#48
Rack::Multipart::Parser::TEXT_PLAIN = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/multipart/parser.rb#35
Rack::Multipart::REGULAR_PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#34
Rack::Multipart::REGULAR_PARAMETER_NAME = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#44
Rack::Multipart::RFC2183 = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#33
Rack::Multipart::SECTION = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/parser.rb#23
Rack::Multipart::TOKEN = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/multipart/uploaded_file.rb#8
class Rack::Multipart::UploadedFile
  # source://rack//lib/rack/multipart/uploaded_file.rb#16
  def initialize(filepath = T.unsafe(nil), ct = T.unsafe(nil), bin = T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://rack//lib/rack/multipart/uploaded_file.rb#14
  def content_type; end

  # source://rack//lib/rack/multipart/uploaded_file.rb#14
  def content_type=(_arg0); end

  # source://rack//lib/rack/multipart/uploaded_file.rb#31
  def local_path; end

  # source://rack//lib/rack/multipart/uploaded_file.rb#40
  def method_missing(method_name, *args, &block); end

  # source://rack//lib/rack/multipart/uploaded_file.rb#11
  def original_filename; end

  # source://rack//lib/rack/multipart/uploaded_file.rb#31
  def path; end

  # source://rack//lib/rack/multipart/uploaded_file.rb#36
  def respond_to?(*args); end
end

# source://rack//lib/rack/multipart/parser.rb#25
Rack::Multipart::VALUE = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/null_logger.rb#6
class Rack::NullLogger
  # source://rack//lib/rack/null_logger.rb#7
  def initialize(app); end

  # source://rack//lib/rack/null_logger.rb#45
  def <<(msg); end

  # source://rack//lib/rack/null_logger.rb#43
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#11
  def call(env); end

  # source://rack//lib/rack/null_logger.rb#42
  def close; end

  # source://rack//lib/rack/null_logger.rb#34
  def datetime_format; end

  # source://rack//lib/rack/null_logger.rb#39
  def datetime_format=(datetime_format); end

  # source://rack//lib/rack/null_logger.rb#17
  def debug(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#27
  def debug!; end

  # source://rack//lib/rack/null_logger.rb#23
  def debug?; end

  # source://rack//lib/rack/null_logger.rb#19
  def error(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#28
  def error!; end

  # source://rack//lib/rack/null_logger.rb#25
  def error?; end

  # source://rack//lib/rack/null_logger.rb#20
  def fatal(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#29
  def fatal!; end

  # source://rack//lib/rack/null_logger.rb#26
  def fatal?; end

  # source://rack//lib/rack/null_logger.rb#35
  def formatter; end

  # source://rack//lib/rack/null_logger.rb#40
  def formatter=(formatter); end

  # source://rack//lib/rack/null_logger.rb#16
  def info(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#30
  def info!; end

  # source://rack//lib/rack/null_logger.rb#22
  def info?; end

  # source://rack//lib/rack/null_logger.rb#32
  def level; end

  # source://rack//lib/rack/null_logger.rb#37
  def level=(level); end

  # source://rack//lib/rack/null_logger.rb#44
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#33
  def progname; end

  # source://rack//lib/rack/null_logger.rb#38
  def progname=(progname); end

  # source://rack//lib/rack/null_logger.rb#46
  def reopen(logdev = T.unsafe(nil)); end

  # source://rack//lib/rack/null_logger.rb#36
  def sev_threshold; end

  # source://rack//lib/rack/null_logger.rb#41
  def sev_threshold=(sev_threshold); end

  # source://rack//lib/rack/null_logger.rb#21
  def unknown(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#18
  def warn(progname = T.unsafe(nil), &block); end

  # source://rack//lib/rack/null_logger.rb#31
  def warn!; end

  # source://rack//lib/rack/null_logger.rb#24
  def warn?; end
end

# source://rack//lib/rack/constants.rb#34
Rack::OPTIONS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#31
Rack::PATCH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#8
Rack::PATH_INFO = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#29
Rack::POST = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#30
Rack::PUT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#12
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/query_parser.rb#6
class Rack::QueryParser
  # source://rack//lib/rack/query_parser.rb#33
  def initialize(params_class, _key_space_limit = T.unsafe(nil), param_depth_limit); end

  # source://rack//lib/rack/query_parser.rb#167
  def make_params; end

  # source://rack//lib/rack/query_parser.rb#171
  def new_depth_limit(param_depth_limit); end

  # source://rack//lib/rack/query_parser.rb#95
  def normalize_params(params, name, v, _depth = T.unsafe(nil)); end

  # source://rack//lib/rack/query_parser.rb#31
  def param_depth_limit; end

  # source://rack//lib/rack/query_parser.rb#74
  def parse_nested_query(qs, separator = T.unsafe(nil)); end

  # source://rack//lib/rack/query_parser.rb#46
  def parse_query(qs, separator = T.unsafe(nil), &unescaper); end

  private

  # source://rack//lib/rack/query_parser.rb#99
  def _normalize_params(params, name, v, depth); end

  # source://rack//lib/rack/query_parser.rb#181
  def params_hash_has_key?(hash, key); end

  # source://rack//lib/rack/query_parser.rb#177
  def params_hash_type?(obj); end

  # source://rack//lib/rack/query_parser.rb#193
  def unescape(string, encoding = T.unsafe(nil)); end

  class << self
    # source://rack//lib/rack/query_parser.rb#23
    def make_default(_key_space_limit = T.unsafe(nil), param_depth_limit); end
  end
end

# source://rack//lib/rack/query_parser.rb#8
Rack::QueryParser::COMMON_SEP = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/query_parser.rb#7
Rack::QueryParser::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/query_parser.rb#17
class Rack::QueryParser::InvalidParameterError < ::ArgumentError; end

# source://rack//lib/rack/query_parser.rb#12
class Rack::QueryParser::ParameterTypeError < ::TypeError; end

# source://rack//lib/rack/query_parser.rb#197
class Rack::QueryParser::Params
  # source://rack//lib/rack/query_parser.rb#198
  def initialize; end

  # source://rack//lib/rack/query_parser.rb#203
  def [](key); end

  # source://rack//lib/rack/query_parser.rb#207
  def []=(key, value); end

  # source://rack//lib/rack/query_parser.rb#211
  def key?(key); end

  # source://rack//lib/rack/query_parser.rb#233
  def to_h; end

  # source://rack//lib/rack/query_parser.rb#233
  def to_params_hash; end
end

# source://rack//lib/rack/query_parser.rb#21
class Rack::QueryParser::ParamsTooDeepError < ::RangeError; end

# source://rack//lib/rack/constants.rb#42
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#49
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#44
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#50
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#43
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#63
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#52
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#53
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#51
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#59
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#60
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#58
Rack::RACK_REQUEST_FORM_ERROR = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#56
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#55
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#57
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#61
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#62
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#54
Rack::RACK_RESPONSE_FINISHED = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#45
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#46
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#47
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#41
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#48
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#40
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/version.rb#28
Rack::RELEASE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#9
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#10
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/recursive.rb#36
class Rack::Recursive
  # source://rack//lib/rack/recursive.rb#37
  def initialize(app); end

  # source://rack//lib/rack/recursive.rb#45
  def _call(env); end

  # source://rack//lib/rack/recursive.rb#41
  def call(env); end

  # source://rack//lib/rack/recursive.rb#52
  def include(env, path); end
end

# source://rack//lib/rack/reloader.rb#24
class Rack::Reloader
  # source://rack//lib/rack/reloader.rb#25
  def initialize(app, cooldown = T.unsafe(nil), backend = T.unsafe(nil)); end

  # source://rack//lib/rack/reloader.rb#36
  def call(env); end

  # source://rack//lib/rack/reloader.rb#50
  def reload!(stderr = T.unsafe(nil)); end

  # source://rack//lib/rack/reloader.rb#58
  def safe_load(file, mtime, stderr = T.unsafe(nil)); end
end

# source://rack//lib/rack/reloader.rb#68
module Rack::Reloader::Stat
  # source://rack//lib/rack/reloader.rb#88
  def figure_path(file, paths); end

  # source://rack//lib/rack/reloader.rb#69
  def rotation; end

  # source://rack//lib/rack/reloader.rb#103
  def safe_stat(file); end
end

# source://rack//lib/rack/request.rb#16
class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers

  # source://rack//lib/rack/request.rb#62
  def initialize(env); end

  # source://rack//lib/rack/request.rb#76
  def delete_param(k); end

  # source://rack//lib/rack/request.rb#67
  def params; end

  # source://rack//lib/rack/request.rb#67
  def query; end

  # source://rack//lib/rack/request.rb#71
  def update_param(k, v); end

  # source://yard/0.9.36/lib/yard/server/rack_adapter.rb#94
  def version_supplied; end

  # source://yard/0.9.36/lib/yard/server/rack_adapter.rb#94
  def version_supplied=(_arg0); end

  # source://yard/0.9.36/lib/yard/server/rack_adapter.rb#96
  def xhr?; end

  class << self
    # source://rack//lib/rack/request.rb#31
    def forwarded_priority; end

    # source://rack//lib/rack/request.rb#31
    def forwarded_priority=(_arg0); end

    # source://rack//lib/rack/request.rb#18
    def ip_filter; end

    # source://rack//lib/rack/request.rb#18
    def ip_filter=(_arg0); end

    # source://rack//lib/rack/request.rb#40
    def x_forwarded_proto_priority; end

    # source://rack//lib/rack/request.rb#40
    def x_forwarded_proto_priority=(_arg0); end
  end
end

# source://rack//lib/rack/request.rb#60
Rack::Request::ALLOWED_SCHEMES = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/request.rb#82
module Rack::Request::Env
  # source://rack//lib/rack/request.rb#86
  def initialize(env); end

  # source://rack//lib/rack/request.rb#129
  def add_header(key, v); end

  # source://rack//lib/rack/request.rb#140
  def delete_header(name); end

  # source://rack//lib/rack/request.rb#111
  def each_header(&block); end

  # source://rack//lib/rack/request.rb#84
  def env; end

  # source://rack//lib/rack/request.rb#106
  def fetch_header(name, &block); end

  # source://rack//lib/rack/request.rb#100
  def get_header(name); end

  # source://rack//lib/rack/request.rb#95
  def has_header?(name); end

  # source://rack//lib/rack/request.rb#116
  def set_header(name, v); end

  private

  # source://rack//lib/rack/request.rb#144
  def initialize_copy(other); end
end

# source://rack//lib/rack/request.rb#149
module Rack::Request::Helpers
  # source://rack//lib/rack/request.rb#484
  def GET; end

  # source://rack//lib/rack/request.rb#498
  def POST; end

  # source://rack//lib/rack/request.rb#609
  def [](key); end

  # source://rack//lib/rack/request.rb#618
  def []=(key, value); end

  # source://rack//lib/rack/request.rb#596
  def accept_encoding; end

  # source://rack//lib/rack/request.rb#600
  def accept_language; end

  # source://rack//lib/rack/request.rb#266
  def authority; end

  # source://rack//lib/rack/request.rb#579
  def base_url; end

  # source://rack//lib/rack/request.rb#190
  def body; end

  # source://rack//lib/rack/request.rb#458
  def content_charset; end

  # source://rack//lib/rack/request.rb#199
  def content_length; end

  # source://rack//lib/rack/request.rb#308
  def content_type; end

  # source://rack//lib/rack/request.rb#293
  def cookies; end

  # source://rack//lib/rack/request.rb#220
  def delete?; end

  # source://rack//lib/rack/request.rb#574
  def delete_param(k); end

  # source://rack//lib/rack/request.rb#470
  def form_data?; end

  # source://rack//lib/rack/request.rb#393
  def forwarded_authority; end

  # source://rack//lib/rack/request.rb#353
  def forwarded_for; end

  # source://rack//lib/rack/request.rb#374
  def forwarded_port; end

  # source://rack//lib/rack/request.rb#592
  def fullpath; end

  # source://rack//lib/rack/request.rb#223
  def get?; end

  # source://rack//lib/rack/request.rb#226
  def head?; end

  # source://rack//lib/rack/request.rb#333
  def host; end

  # source://rack//lib/rack/request.rb#318
  def host_authority; end

  # source://rack//lib/rack/request.rb#322
  def host_with_port(authority = T.unsafe(nil)); end

  # source://rack//lib/rack/request.rb#341
  def hostname; end

  # source://rack//lib/rack/request.rb#414
  def ip; end

  # source://rack//lib/rack/request.rb#232
  def link?; end

  # source://rack//lib/rack/request.rb#200
  def logger; end

  # source://rack//lib/rack/request.rb#441
  def media_type; end

  # source://rack//lib/rack/request.rb#450
  def media_type_params; end

  # source://rack//lib/rack/request.rb#229
  def options?; end

  # source://rack//lib/rack/request.rb#545
  def params; end

  # source://rack//lib/rack/request.rb#479
  def parseable_data?; end

  # source://rack//lib/rack/request.rb#235
  def patch?; end

  # source://rack//lib/rack/request.rb#588
  def path; end

  # source://rack//lib/rack/request.rb#194
  def path_info; end

  # source://rack//lib/rack/request.rb#195
  def path_info=(s); end

  # source://rack//lib/rack/request.rb#345
  def port; end

  # source://rack//lib/rack/request.rb#238
  def post?; end

  # source://rack//lib/rack/request.rb#241
  def put?; end

  # source://rack//lib/rack/request.rb#198
  def query_string; end

  # source://rack//lib/rack/request.rb#204
  def referer; end

  # source://rack//lib/rack/request.rb#204
  def referrer; end

  # source://rack//lib/rack/request.rb#197
  def request_method; end

  # source://rack//lib/rack/request.rb#249
  def scheme; end

  # source://rack//lib/rack/request.rb#191
  def script_name; end

  # source://rack//lib/rack/request.rb#192
  def script_name=(s); end

  # source://rack//lib/rack/request.rb#272
  def server_authority; end

  # source://rack//lib/rack/request.rb#285
  def server_name; end

  # source://rack//lib/rack/request.rb#289
  def server_port; end

  # source://rack//lib/rack/request.rb#207
  def session; end

  # source://rack//lib/rack/request.rb#213
  def session_options; end

  # source://rack//lib/rack/request.rb#410
  def ssl?; end

  # source://rack//lib/rack/request.rb#244
  def trace?; end

  # source://rack//lib/rack/request.rb#604
  def trusted_proxy?(ip); end

  # source://rack//lib/rack/request.rb#247
  def unlink?; end

  # source://rack//lib/rack/request.rb#554
  def update_param(k, v); end

  # source://rack//lib/rack/request.rb#584
  def url; end

  # source://rack//lib/rack/request.rb#201
  def user_agent; end

  # source://rack//lib/rack/request.rb#625
  def values_at(*keys); end

  # source://rack//lib/rack/request.rb#313
  def xhr?; end

  private

  # source://rack//lib/rack/request.rb#757
  def allowed_scheme(header); end

  # source://rack//lib/rack/request.rb#631
  def default_session; end

  # source://rack//lib/rack/request.rb#761
  def forwarded_priority; end

  # source://rack//lib/rack/request.rb#733
  def forwarded_scheme; end

  # source://rack//lib/rack/request.rb#659
  def get_http_forwarded(token); end

  # source://rack//lib/rack/request.rb#647
  def parse_http_accept_header(header); end

  # source://rack//lib/rack/request.rb#671
  def parse_multipart; end

  # source://rack//lib/rack/request.rb#667
  def parse_query(qs, d = T.unsafe(nil)); end

  # source://rack//lib/rack/request.rb#663
  def query_parser; end

  # source://rack//lib/rack/request.rb#724
  def reject_trusted_ip_addresses(ip_addresses); end

  # source://rack//lib/rack/request.rb#718
  def split_authority(authority); end

  # source://rack//lib/rack/request.rb#675
  def split_header(value); end

  # source://rack//lib/rack/request.rb#634
  def wrap_ipv6(host); end

  # source://rack//lib/rack/request.rb#765
  def x_forwarded_proto_priority; end
end

# source://rack//lib/rack/request.rb#703
Rack::Request::Helpers::AUTHORITY = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/request.rb#168
Rack::Request::Helpers::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/request.rb#153
Rack::Request::Helpers::FORM_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/request.rb#728
Rack::Request::Helpers::FORWARDED_SCHEME_HEADERS = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/request.rb#176
Rack::Request::Helpers::HTTP_FORWARDED = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/request.rb#171
Rack::Request::Helpers::HTTP_X_FORWARDED_FOR = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/request.rb#174
Rack::Request::Helpers::HTTP_X_FORWARDED_HOST = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/request.rb#185
Rack::Request::Helpers::HTTP_X_FORWARDED_PORT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/request.rb#182
Rack::Request::Helpers::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/request.rb#179
Rack::Request::Helpers::HTTP_X_FORWARDED_SCHEME = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/request.rb#188
Rack::Request::Helpers::HTTP_X_FORWARDED_SSL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/request.rb#161
Rack::Request::Helpers::PARSEABLE_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/response.rb#23
class Rack::Response
  include ::Rack::Response::Helpers

  # source://rack//lib/rack/response.rb#61
  def initialize(body = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil)); end

  # source://rack//lib/rack/response.rb#163
  def [](key); end

  # source://rack//lib/rack/response.rb#167
  def []=(key, value); end

  # source://rack//lib/rack/response.rb#31
  def body; end

  # source://rack//lib/rack/response.rb#31
  def body=(_arg0); end

  # source://rack//lib/rack/response.rb#101
  def chunked?; end

  # source://rack//lib/rack/response.rb#151
  def close; end

  # source://rack//lib/rack/response.rb#171
  def delete_header(key); end

  # source://rack//lib/rack/response.rb#131
  def each(&callback); end

  # source://rack//lib/rack/response.rb#155
  def empty?; end

  # source://rack//lib/rack/response.rb#113
  def finish(&block); end

  # source://rack//lib/rack/response.rb#163
  def get_header(key); end

  # source://rack//lib/rack/response.rb#159
  def has_header?(key); end

  # source://rack//lib/rack/response.rb#35
  def header; end

  # source://rack//lib/rack/response.rb#32
  def headers; end

  # source://rack//lib/rack/response.rb#31
  def length; end

  # source://rack//lib/rack/response.rb#31
  def length=(_arg0); end

  # source://rack//lib/rack/response.rb#105
  def no_entity_body?; end

  # source://rack//lib/rack/response.rb#96
  def redirect(target, status = T.unsafe(nil)); end

  # source://rack//lib/rack/response.rb#167
  def set_header(key, value); end

  # source://rack//lib/rack/response.rb#31
  def status; end

  # source://rack//lib/rack/response.rb#31
  def status=(_arg0); end

  # source://rack//lib/rack/response.rb#113
  def to_a(&block); end

  # source://rack//lib/rack/response.rb#145
  def write(chunk); end

  class << self
    # source://rack//lib/rack/response.rb#24
    def [](status, headers, body); end
  end
end

# source://rack//lib/rack/response.rb#28
Rack::Response::CHUNKED = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/response.rb#179
module Rack::Response::Helpers
  # source://rack//lib/rack/response.rb#190
  def accepted?; end

  # source://rack//lib/rack/response.rb#218
  def add_header(key, value); end

  # source://rack//lib/rack/response.rb#193
  def bad_request?; end

  # source://rack//lib/rack/response.rb#306
  def cache!(duration = T.unsafe(nil), directive: T.unsafe(nil)); end

  # source://rack//lib/rack/response.rb#289
  def cache_control; end

  # source://rack//lib/rack/response.rb#293
  def cache_control=(value); end

  # source://rack//lib/rack/response.rb#185
  def client_error?; end

  # source://rack//lib/rack/response.rb#256
  def content_length; end

  # source://rack//lib/rack/response.rb#239
  def content_type; end

  # source://rack//lib/rack/response.rb#244
  def content_type=(content_type); end

  # source://rack//lib/rack/response.rb#189
  def created?; end

  # source://rack//lib/rack/response.rb#273
  def delete_cookie(key, value = T.unsafe(nil)); end

  # source://rack//lib/rack/response.rb#298
  def do_not_cache!; end

  # source://rack//lib/rack/response.rb#313
  def etag; end

  # source://rack//lib/rack/response.rb#317
  def etag=(value); end

  # source://rack//lib/rack/response.rb#195
  def forbidden?; end

  # source://rack//lib/rack/response.rb#205
  def include?(header); end

  # source://rack//lib/rack/response.rb#182
  def informational?; end

  # source://rack//lib/rack/response.rb#180
  def invalid?; end

  # source://rack//lib/rack/response.rb#261
  def location; end

  # source://rack//lib/rack/response.rb#265
  def location=(location); end

  # source://rack//lib/rack/response.rb#248
  def media_type; end

  # source://rack//lib/rack/response.rb#252
  def media_type_params; end

  # source://rack//lib/rack/response.rb#197
  def method_not_allowed?; end

  # source://rack//lib/rack/response.rb#192
  def moved_permanently?; end

  # source://rack//lib/rack/response.rb#191
  def no_content?; end

  # source://rack//lib/rack/response.rb#198
  def not_acceptable?; end

  # source://rack//lib/rack/response.rb#196
  def not_found?; end

  # source://rack//lib/rack/response.rb#188
  def ok?; end

  # source://rack//lib/rack/response.rb#200
  def precondition_failed?; end

  # source://rack//lib/rack/response.rb#203
  def redirect?; end

  # source://rack//lib/rack/response.rb#184
  def redirection?; end

  # source://rack//lib/rack/response.rb#199
  def request_timeout?; end

  # source://rack//lib/rack/response.rb#186
  def server_error?; end

  # source://rack//lib/rack/response.rb#269
  def set_cookie(key, value); end

  # source://rack//lib/rack/response.rb#281
  def set_cookie_header; end

  # source://rack//lib/rack/response.rb#285
  def set_cookie_header=(value); end

  # source://rack//lib/rack/response.rb#183
  def successful?; end

  # source://rack//lib/rack/response.rb#194
  def unauthorized?; end

  # source://rack//lib/rack/response.rb#201
  def unprocessable?; end

  protected

  # source://rack//lib/rack/response.rb#353
  def append(chunk); end

  # source://rack//lib/rack/response.rb#323
  def buffered_body!; end
end

# source://rack//lib/rack/response.rb#367
class Rack::Response::Raw
  include ::Rack::Response::Helpers

  # source://rack//lib/rack/response.rb#373
  def initialize(status, headers); end

  # source://rack//lib/rack/response.rb#390
  def delete_header(key); end

  # source://rack//lib/rack/response.rb#382
  def get_header(key); end

  # source://rack//lib/rack/response.rb#378
  def has_header?(key); end

  # source://rack//lib/rack/response.rb#370
  def headers; end

  # source://rack//lib/rack/response.rb#386
  def set_header(key, value); end

  # source://rack//lib/rack/response.rb#371
  def status; end

  # source://rack//lib/rack/response.rb#371
  def status=(_arg0); end
end

# source://rack//lib/rack/response.rb#29
Rack::Response::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/rewindable_input.rb#14
class Rack::RewindableInput
  # source://rack//lib/rack/rewindable_input.rb#29
  def initialize(io); end

  # source://rack//lib/rack/rewindable_input.rb#65
  def close; end

  # source://rack//lib/rack/rewindable_input.rb#45
  def each(&block); end

  # source://rack//lib/rack/rewindable_input.rb#35
  def gets; end

  # source://rack//lib/rack/rewindable_input.rb#40
  def read(*args); end

  # source://rack//lib/rack/rewindable_input.rb#50
  def rewind; end

  # source://rack//lib/rack/rewindable_input.rb#55
  def size; end

  private

  # source://rack//lib/rack/rewindable_input.rb#109
  def filesystem_has_posix_semantics?; end

  # source://rack//lib/rack/rewindable_input.rb#78
  def make_rewindable; end
end

# source://rack//lib/rack/rewindable_input.rb#18
class Rack::RewindableInput::Middleware
  # source://rack//lib/rack/rewindable_input.rb#19
  def initialize(app); end

  # source://rack//lib/rack/rewindable_input.rb#23
  def call(env); end
end

# source://rack//lib/rack/runtime.rb#12
class Rack::Runtime
  # source://rack//lib/rack/runtime.rb#16
  def initialize(app, name = T.unsafe(nil)); end

  # source://rack//lib/rack/runtime.rb#22
  def call(env); end
end

# source://rack//lib/rack/runtime.rb#13
Rack::Runtime::FORMAT_STRING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/runtime.rb#14
Rack::Runtime::HEADER_NAME = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#11
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#14
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#15
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#13
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#24
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/sendfile.rb#104
class Rack::Sendfile
  # source://rack//lib/rack/sendfile.rb#105
  def initialize(app, variation = T.unsafe(nil), mappings = T.unsafe(nil)); end

  # source://rack//lib/rack/sendfile.rb#113
  def call(env); end

  private

  # source://rack//lib/rack/sendfile.rb#154
  def map_accel_path(env, path); end

  # source://rack//lib/rack/sendfile.rb#148
  def variation(env); end
end

# source://rack//lib/rack/show_exceptions.rb#19
class Rack::ShowExceptions
  # source://rack//lib/rack/show_exceptions.rb#22
  def initialize(app); end

  # source://rack//lib/rack/show_exceptions.rb#26
  def call(env); end

  # source://rack//lib/rack/show_exceptions.rb#61
  def dump_exception(exception); end

  # source://rack//lib/rack/show_exceptions.rb#112
  def h(obj); end

  # source://rack//lib/rack/show_exceptions.rb#52
  def prefers_plaintext?(env); end

  # source://rack//lib/rack/show_exceptions.rb#72
  def pretty(env, exception); end

  # source://rack//lib/rack/show_exceptions.rb#108
  def template; end

  private

  # source://rack//lib/rack/show_exceptions.rb#56
  def accepts_html?(env); end
end

# source://rack//lib/rack/show_exceptions.rb#20
Rack::ShowExceptions::CONTEXT = T.let(T.unsafe(nil), Integer)

# source://rack//lib/rack/show_exceptions.rb#127
Rack::ShowExceptions::TEMPLATE = T.let(T.unsafe(nil), ERB)

# source://rack//lib/rack/show_status.rb#18
class Rack::ShowStatus
  # source://rack//lib/rack/show_status.rb#19
  def initialize(app); end

  # source://rack//lib/rack/show_status.rb#24
  def call(env); end

  # source://rack//lib/rack/show_status.rb#54
  def h(obj); end
end

# source://rack//lib/rack/show_status.rb#69
Rack::ShowStatus::TEMPLATE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/static.rb#92
class Rack::Static
  # source://rack//lib/rack/static.rb#93
  def initialize(app, options = T.unsafe(nil)); end

  # source://rack//lib/rack/static.rb#109
  def add_index_root?(path); end

  # source://rack//lib/rack/static.rb#166
  def applicable_rules(path); end

  # source://rack//lib/rack/static.rb#125
  def call(env); end

  # source://rack//lib/rack/static.rb#121
  def can_serve(path); end

  # source://rack//lib/rack/static.rb#113
  def overwrite_file_path(path); end

  # source://rack//lib/rack/static.rb#117
  def route_file(path); end
end

# source://rack//lib/rack/constants.rb#37
Rack::TRACE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/constants.rb#25
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/tempfile_reaper.rb#11
class Rack::TempfileReaper
  # source://rack//lib/rack/tempfile_reaper.rb#12
  def initialize(app); end

  # source://rack//lib/rack/tempfile_reaper.rb#16
  def call(env); end
end

# source://rack//lib/rack/constants.rb#36
Rack::UNLINK = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/urlmap.rb#20
class Rack::URLMap
  # source://rack//lib/rack/urlmap.rb#21
  def initialize(map = T.unsafe(nil)); end

  # source://rack//lib/rack/urlmap.rb#48
  def call(env); end

  # source://rack//lib/rack/urlmap.rb#25
  def remap(map); end

  private

  # source://rack//lib/rack/urlmap.rb#87
  def casecmp?(v1, v2); end
end

# source://rack//lib/rack/utils.rb#19
module Rack::Utils
  private

  # source://rack//lib/rack/utils.rb#255
  def add_cookie_to_header(header, key, value); end

  # source://rack//lib/rack/utils.rb#390
  def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

  # source://rack//lib/rack/utils.rb#174
  def best_q_match(q_value_header, available_mimes); end

  # source://rack//lib/rack/utils.rb#127
  def build_nested_query(value, prefix = T.unsafe(nil)); end

  # source://rack//lib/rack/utils.rb#117
  def build_query(params); end

  # source://rack//lib/rack/utils.rb#432
  def byte_ranges(env, size); end

  # source://rack//lib/rack/utils.rb#636
  def clean_path_info(path_info); end

  # source://rack//lib/rack/utils.rb#98
  def clock_time; end

  # source://rack//lib/rack/utils.rb#384
  def delete_cookie_header!(headers, key, value = T.unsafe(nil)); end

  # source://rack//lib/rack/utils.rb#374
  def delete_set_cookie_header(key, value = T.unsafe(nil)); end

  # source://rack//lib/rack/utils.rb#414
  def delete_set_cookie_header!(header, key, value = T.unsafe(nil)); end

  # source://rack//lib/rack/utils.rb#38
  def escape(s); end

  # source://rack//lib/rack/utils.rb#199
  def escape_html(string); end

  # source://rack//lib/rack/utils.rb#44
  def escape_path(s); end

  # source://rack//lib/rack/utils.rb#156
  def forwarded_values(forwarded_header); end

  # source://rack//lib/rack/utils.rb#436
  def get_byte_ranges(http_range, size); end

  # source://rack//lib/rack/utils.rb#378
  def make_delete_cookie_header(header, key, value); end

  # source://rack//lib/rack/utils.rb#279
  def parse_cookies(env); end

  # source://rack//lib/rack/utils.rb#245
  def parse_cookies_header(value); end

  # source://rack//lib/rack/utils.rb#113
  def parse_nested_query(qs, d = T.unsafe(nil)); end

  # source://rack//lib/rack/utils.rb#109
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end

  # source://rack//lib/rack/utils.rb#145
  def q_values(q_value_header); end

  # source://rack//lib/rack/utils.rb#425
  def rfc2822(time); end

  # source://rack//lib/rack/utils.rb#476
  def secure_compare(a, b); end

  # source://rack//lib/rack/utils.rb#203
  def select_best_encoding(available_encodings, accept_encoding); end

  # source://rack//lib/rack/utils.rb#306
  def set_cookie_header(key, value); end

  # source://rack//lib/rack/utils.rb#348
  def set_cookie_header!(headers, key, value); end

  # source://rack//lib/rack/utils.rb#626
  def status_code(status); end

  # source://rack//lib/rack/utils.rb#56
  def unescape(s, encoding = T.unsafe(nil)); end

  # source://rack//lib/rack/utils.rb#50
  def unescape_path(s); end

  # source://rack//lib/rack/utils.rb#653
  def valid_path?(path); end

  class << self
    # source://rack//lib/rack/utils.rb#255
    def add_cookie_to_header(header, key, value); end

    # source://rack//lib/rack/utils.rb#390
    def add_remove_cookie_to_header(header, key, value = T.unsafe(nil)); end

    # source://rack//lib/rack/utils.rb#174
    def best_q_match(q_value_header, available_mimes); end

    # source://rack//lib/rack/utils.rb#127
    def build_nested_query(value, prefix = T.unsafe(nil)); end

    # source://rack//lib/rack/utils.rb#117
    def build_query(params); end

    # source://rack//lib/rack/utils.rb#432
    def byte_ranges(env, size); end

    # source://rack//lib/rack/utils.rb#636
    def clean_path_info(path_info); end

    # source://rack//lib/rack/utils.rb#98
    def clock_time; end

    # source://rack//lib/rack/utils.rb#28
    def default_query_parser; end

    # source://rack//lib/rack/utils.rb#28
    def default_query_parser=(_arg0); end

    # source://rack//lib/rack/utils.rb#384
    def delete_cookie_header!(headers, key, value = T.unsafe(nil)); end

    # source://rack//lib/rack/utils.rb#374
    def delete_set_cookie_header(key, value = T.unsafe(nil)); end

    # source://rack//lib/rack/utils.rb#414
    def delete_set_cookie_header!(header, key, value = T.unsafe(nil)); end

    # source://rack//lib/rack/utils.rb#38
    def escape(s); end

    # source://rack//lib/rack/utils.rb#199
    def escape_html(string); end

    # source://rack//lib/rack/utils.rb#44
    def escape_path(s); end

    # source://rack//lib/rack/utils.rb#156
    def forwarded_values(forwarded_header); end

    # source://rack//lib/rack/utils.rb#436
    def get_byte_ranges(http_range, size); end

    # source://rack//lib/rack/utils.rb#88
    def key_space_limit; end

    # source://rack//lib/rack/utils.rb#93
    def key_space_limit=(v); end

    # source://rack//lib/rack/utils.rb#378
    def make_delete_cookie_header(header, key, value); end

    # source://rack//lib/rack/utils.rb#63
    def multipart_file_limit; end

    # source://rack//lib/rack/utils.rb#63
    def multipart_file_limit=(_arg0); end

    # source://rack//lib/rack/utils.rb#63
    def multipart_part_limit; end

    # source://rack//lib/rack/utils.rb#63
    def multipart_part_limit=(_arg0); end

    # source://rack//lib/rack/utils.rb#61
    def multipart_total_part_limit; end

    # source://rack//lib/rack/utils.rb#61
    def multipart_total_part_limit=(_arg0); end

    # source://rack//lib/rack/utils.rb#80
    def param_depth_limit; end

    # source://rack//lib/rack/utils.rb#84
    def param_depth_limit=(v); end

    # source://rack//lib/rack/utils.rb#279
    def parse_cookies(env); end

    # source://rack//lib/rack/utils.rb#245
    def parse_cookies_header(value); end

    # source://rack//lib/rack/utils.rb#113
    def parse_nested_query(qs, d = T.unsafe(nil)); end

    # source://rack//lib/rack/utils.rb#109
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end

    # source://rack//lib/rack/utils.rb#145
    def q_values(q_value_header); end

    # source://rack//lib/rack/utils.rb#425
    def rfc2822(time); end

    # source://rack//lib/rack/utils.rb#476
    def secure_compare(a, b); end

    # source://rack//lib/rack/utils.rb#203
    def select_best_encoding(available_encodings, accept_encoding); end

    # source://rack//lib/rack/utils.rb#306
    def set_cookie_header(key, value); end

    # source://rack//lib/rack/utils.rb#348
    def set_cookie_header!(headers, key, value); end

    # source://rack//lib/rack/utils.rb#626
    def status_code(status); end

    # source://rack//lib/rack/utils.rb#56
    def unescape(s, encoding = T.unsafe(nil)); end

    # source://rack//lib/rack/utils.rb#50
    def unescape_path(s); end

    # source://rack//lib/rack/utils.rb#653
    def valid_path?(path); end
  end
end

# source://rack//lib/rack/utils.rb#24
Rack::Utils::COMMON_SEP = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/utils.rb#499
class Rack::Utils::Context
  # source://rack//lib/rack/utils.rb#502
  def initialize(app_f, app_r); end

  # source://rack//lib/rack/utils.rb#500
  def app; end

  # source://rack//lib/rack/utils.rb#507
  def call(env); end

  # source://rack//lib/rack/utils.rb#515
  def context(env, app = T.unsafe(nil)); end

  # source://rack//lib/rack/utils.rb#500
  def for; end

  # source://rack//lib/rack/utils.rb#511
  def recontext(app); end
end

# source://rack//lib/rack/utils.rb#23
Rack::Utils::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/utils.rb#187
Rack::Utils::ESCAPE_HTML = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/utils.rb#196
Rack::Utils::ESCAPE_HTML_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/utils.rb#553
Rack::Utils::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/utils.rb#524
class Rack::Utils::HeaderHash < ::Hash
  class << self
    # source://rack//lib/rack/utils.rb#525
    def [](headers); end

    # source://rack//lib/rack/utils.rb#543
    def allocate; end

    # source://rack//lib/rack/utils.rb#536
    def new(hash = T.unsafe(nil)); end
  end
end

# source://rack//lib/rack/utils.rb#21
Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

# source://rack//lib/rack/utils.rb#25
Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

# source://rack//lib/rack/utils.rb#651
Rack::Utils::NULL_BYTE = T.let(T.unsafe(nil), String)

# source://rack//lib/rack/utils.rb#634
Rack::Utils::PATH_SEPS = T.let(T.unsafe(nil), Regexp)

# source://rack//lib/rack/utils.rb#20
Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

# source://rack//lib/rack/utils.rb#22
Rack::Utils::ParamsTooDeepError = Rack::QueryParser::ParamsTooDeepError

# source://rack//lib/rack/utils.rb#620
Rack::Utils::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/utils.rb#622
Rack::Utils::SYMBOL_TO_STATUS_CODE = T.let(T.unsafe(nil), Hash)

# source://rack//lib/rack/version.rb#16
Rack::VERSION = T.let(T.unsafe(nil), Array)

# source://rack//lib/rack/version.rb#19
Rack::VERSION_STRING = T.let(T.unsafe(nil), String)
